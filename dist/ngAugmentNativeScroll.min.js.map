{"version":3,"sources":["webpack:///ngAugmentNativeScroll.min.js","webpack:///webpack/bootstrap 845f6d34b4c6f67f10f7","webpack:///./src/augNsOptions.value.js","webpack:///./src/augNsUtils.factory.js","webpack:///./src/connectScrolls.directive.js","webpack:///./src/kineticEngine.value.js","webpack:///./src/kineticScroll.directive.js","webpack:///./src/scrollArea.directive.js","webpack:///external \"angular\"","webpack:///./src/index.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","augNsOptions","enableKinetics","movingAverage","preventDefaultException","tagName","augNsUtils","lastTime","vendors","x","length","window","requestAnimationFrame","cancelAnimationFrame","callback","currTime","Date","getTime","timeToCall","Math","max","id","setTimeout","clearTimeout","findMatchingTarget","target","nodes","found","find","node","this","parentElement","getPoint","e","hasTouch","point","event","touches","clientX","y","clientY","now","utils","el","exceptions","test","getMaxScroll","maxScrollLeft","maxScrollTop","forEach","$el","children","maxScrollX","scrollWidth","clientWidth","maxScrollY","scrollHeight","clientHeight","left","top","ConnectScrolls","kineticEngine","restrict","scope","options","transclude","replace","template","link","element","DETECT_EVT","activeId","undefined","$listener","userOptions","angular","extend","setActiveNode","childNodes","cancelAutoScroll","onScroll","valX","valY","pressed","isAutoScrolling","preventDefault","stopPropagation","scrollLeft","lastScrollLeft","scrollTop","lastScrollTop","addEventListener","$on","removeEventListener","$parent","exposedMethods","controller","$scope","addScrollArea","push","$inject","KineticEngine","context","targetTop","targetLeft","velocityTop","velocityLeft","amplitudeTop","amplitudeLeft","timeStamp","referenceX","referenceY","autoScrollTracker","leftTracker","elapsed","delta","topTracker","scroll","correctedLeft","round","correctedTop","autoScroll","deltaY","deltaX","scrollX","scrollY","timeConstant","exp","triggerAutoScroll","tap","swipe","release","scrollGen","start","maxScroll","scrollToBy","addTo","numLeft","corrLeft","numTop","corrTop","moveLeft","moveTop","parseInt","isNaN","notStart","notLeft","notTop","toValue","byValue","scrollToStart","scrollToStartLeft","scrollToStartTop","scrollToEnd","scrollToEndLeft","scrollToEndTop","scrollToPosition","scrollByValue","KineticScroll","ScrollArea","require","attrs","connectScrollsCtrl","attr","random","toString","substring","factory","directive"],"mappings":"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","file":"ngAugmentNativeScroll.min.js","sourcesContent":["/*!\n * v0.13.2\n * \n * MIT License\r\n * \r\n * Copyright (c) 2017 Vijay Dev (http://vijaydev.com/)\r\n * \r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n * \r\n * The above copyright notice and this permission notice shall be included in all\r\n * copies or substantial portions of the Software.\r\n * \r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n * SOFTWARE.\r\n * \n */\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 7);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\n\r\nvar augNsOptions = {\r\n    enableKinetics: true,\r\n    movingAverage: 0.1,\r\n    preventDefaultException: {\r\n        tagName: /^(INPUT|TEXTAREA|BUTTON|SELECT)$/\r\n    }\r\n}\r\n\r\nmodule.exports = augNsOptions;\r\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports) {\n\nfunction augNsUtils () {\r\n     /*eslint-disable angular/window-service, angular/timeout-service */\r\n    (function() {\r\n        var lastTime = 0;\r\n        var vendors = ['ms', 'moz', 'webkit', 'o'];\r\n        for(var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {\r\n            window.requestAnimationFrame = window[vendors[x]+'RequestAnimationFrame'];\r\n            window.cancelAnimationFrame = window[vendors[x]+'CancelAnimationFrame'] || window[vendors[x]+'CancelRequestAnimationFrame'];\r\n        }\r\n\r\n        if ( ! window.requestAnimationFrame ) {\r\n            window.requestAnimationFrame = function(callback) {\r\n                var currTime = new Date().getTime();\r\n                var timeToCall = Math.max(0, 16 - (currTime - lastTime));\r\n                var id = window.setTimeout(function() {\r\n                    callback(currTime + timeToCall);\r\n                }, timeToCall);\r\n                lastTime = currTime + timeToCall;\r\n                return id;\r\n            };\r\n        }\r\n\r\n        if ( ! window.cancelAnimationFrame ) {\r\n            window.cancelAnimationFrame = function(id) {\r\n                clearTimeout(id);\r\n            }\r\n        }\r\n    }());\r\n\r\n    return {\r\n        findMatchingTarget: function (target, nodes) {\r\n            var found;\r\n\r\n            if ( ! nodes.length || target.tagName === 'BODY' ) {\r\n                return 'BODY';\r\n            }\r\n\r\n            found = nodes.find(function (node) {\r\n                return node.id === target.id\r\n            });\r\n\r\n            if ( found ) {\r\n                return target.id;\r\n            } else {\r\n                return this.findMatchingTarget(target.parentElement, nodes);\r\n            }\r\n        },\r\n        getPoint: function (e, hasTouch) {\r\n            var point;\r\n\r\n            if( hasTouch && event.touches.length ) {\r\n                point = {\r\n                    x : event.touches[0].clientX,\r\n                    y : event.touches[0].clientY\r\n                }\r\n            } else {\r\n                point = {\r\n                    x : event.clientX,\r\n                    y : event.clientY\r\n                }\r\n            }\r\n\r\n            return point;\r\n        },\r\n        getTime: Date.now || function getTime () {\r\n            return new Date().utils.getTime();\r\n        },\r\n        preventDefaultException: function (el, exceptions) {\r\n            for ( var i in exceptions ) {\r\n                if ( exceptions[i].test(el[i]) ) {\r\n                    return true;\r\n                }\r\n            }\r\n\r\n            return false;\r\n        },\r\n        getMaxScroll: function (nodes) {\r\n            var maxScrollLeft = 0,\r\n                maxScrollTop = 0;\r\n\r\n            nodes.forEach(function (node) {\r\n                var $el = node.children[0];\r\n                var maxScrollX = $el.scrollWidth - $el.clientWidth;\r\n                var maxScrollY = $el.scrollHeight - $el.clientHeight;\r\n\r\n                if ( maxScrollX > maxScrollLeft ) {\r\n                    maxScrollLeft = maxScrollX;\r\n                }\r\n                if ( maxScrollY > maxScrollTop ) {\r\n                    maxScrollTop = maxScrollY;\r\n                }\r\n            });\r\n\r\n            return {\r\n                left: maxScrollLeft,\r\n                top: maxScrollTop\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nmodule.exports = augNsUtils;\r\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\n\r\nfunction ConnectScrolls (augNsUtils, augNsOptions, kineticEngine) {\r\n    return {\r\n        restrict: 'E',\r\n        scope: {\r\n            options: '='\r\n        },\r\n        transclude: true,\r\n        replace: true,\r\n        template: '<span data-name=\"conntect-scroll\" ng-transclude></span>',\r\n        link: function (scope, element) {\r\n            scope.hasTouch = 'ontouchstart' in window;\r\n            scope.DETECT_EVT = scope.hasTouch ? 'touchstart' : 'mouseover';\r\n            scope.activeId = undefined;\r\n            scope.$listener = element[0];\r\n\r\n            scope.userOptions = angular.extend({}, augNsOptions, scope.options);\r\n\r\n            kineticEngine.call(this, scope, augNsUtils);\r\n\r\n            scope.setActiveNode = function (e) {\r\n                scope.activeId = augNsUtils.findMatchingTarget(e.target, scope.childNodes);\r\n\r\n                // if its a touch device and we are autoscrolling\r\n                // it should stop as soon as the user touches the scroll area\r\n                // else there will be jerky effects\r\n                if ( scope.hasTouch ) {\r\n                    scope.cancelAutoScroll();\r\n                }\r\n            }\r\n\r\n            scope.onScroll = function (e) {\r\n                var target = e.target;\r\n                var valX = undefined;\r\n                var valY = undefined;\r\n\r\n                if ( scope.pressed || scope.isAutoScrolling ) {\r\n                    e.preventDefault();\r\n                    e.stopPropagation();\r\n                    return;\r\n                }\r\n\r\n                if ( target.clientWidth !== target.scrollWidth ) {\r\n                    valX = target.scrollLeft;\r\n                    scope.lastScrollLeft = scope.scrollLeft;\r\n                    scope.scrollLeft = valX;\r\n                } else {\r\n                    valX = scope.scrollLeft;\r\n                }\r\n                if ( target.clientHeight !== target.scrollHeight ) {\r\n                    valY = target.scrollTop;\r\n                    scope.lastScrollTop = scope.scrollTop;\r\n                    scope.scrollTop = valY;\r\n                } else {\r\n                    valY = scope.scrollTop;\r\n                }\r\n\r\n                scope.childNodes.forEach(function(node) {\r\n                    if ( node.id !== scope.activeId ) {\r\n                        node.children[0].scrollLeft = valX;\r\n                        node.children[0].scrollTop = valY;\r\n                    }\r\n                });\r\n            }\r\n\r\n            scope.$listener.addEventListener( scope.DETECT_EVT, scope.setActiveNode, true );\r\n            scope.$listener.addEventListener( 'scroll', scope.onScroll, true );\r\n\r\n            scope.$on('$destroy', function() {\r\n                scope.$listener.removeEventListener( scope.DETECT_EVT, scope.setActiveNode );\r\n                scope.$listener.removeEventListener( 'scroll', scope.onScroll );\r\n            });\r\n\r\n            // expose few methods to the parent controller\r\n            if ( scope.userOptions.hasOwnProperty('name') ) {\r\n                scope.$parent[scope.userOptions.name] = scope.exposedMethods;\r\n            }\r\n        },\r\n        controller: ['$scope', function connectScrollsCtrl($scope) {\r\n            var childNodes = $scope.childNodes = [];\r\n\r\n            this.addScrollArea = function (node) {\r\n                childNodes.push(node);\r\n            }\r\n        }]\r\n    }\r\n}\r\n\r\nConnectScrolls.$inject = ['augNsUtils', 'augNsOptions', 'kineticEngine'];\r\n\r\nmodule.exports = ConnectScrolls;\r\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\n\r\nfunction KineticEngine (context, utils) {\r\n    context.scrollLeft = 0;\r\n    context.scrollTop = 0;\r\n    context.lastScrollLeft = 0;\r\n    context.lastScrollTop = 0;\r\n    context.targetTop = 0;\r\n    context.targetLeft = 0;\r\n\r\n    context.velocityTop = 0;\r\n    context.velocityLeft = 0;\r\n    context.amplitudeTop = 0;\r\n    context.amplitudeLeft = 0;\r\n\r\n    context.timeStamp = 0;\r\n    context.referenceX = 0;\r\n    context.referenceY = 0;\r\n    context.pressed = false;\r\n    context.autoScrollTracker = null;\r\n    context.isAutoScrolling = false;\r\n\r\n    context.leftTracker = function () {\r\n        var now, elapsed, delta;\r\n\r\n        now = utils.getTime();\r\n        elapsed = now - context.timeStamp;\r\n        context.timeStamp = now;\r\n        delta = context.scrollLeft - context.lastScrollLeft;\r\n        context.lastScrollLeft = context.scrollLeft;\r\n\r\n        context.velocityLeft = context.userOptions.movingAverage * (1000 * delta / (1 + elapsed)) + 0.2 * context.velocityLeft;\r\n    }\r\n\r\n    context.topTracker = function () {\r\n        var now, elapsed, delta;\r\n\r\n        now = utils.getTime();\r\n        elapsed = now - context.timeStamp;\r\n        context.timeStamp = now;\r\n        delta = context.scrollTop - context.lastScrollTop;\r\n        context.lastScrollTop = context.scrollTop;\r\n\r\n        context.velocityTop = context.userOptions.movingAverage * (1000 * delta / (1 + elapsed)) + 0.2 * context.velocityTop;\r\n    }\r\n\r\n    context.scroll = function(left, top) {\r\n        var correctedLeft = Math.round(left);\r\n        var correctedTop = Math.round(top);\r\n\r\n        context.childNodes.forEach(function(node) {\r\n            var $el = node.children[0];\r\n            var maxScrollX = $el.scrollWidth - $el.clientWidth;\r\n            var maxScrollY = $el.scrollHeight - $el.clientHeight;\r\n\r\n            if ( maxScrollX > 0 && correctedLeft >= 0 && correctedLeft <= maxScrollX ) {\r\n                $el.scrollLeft = correctedLeft;\r\n                context.scrollLeft = correctedLeft;\r\n            }\r\n            if ( maxScrollY > 0 && correctedTop >= 0 && correctedTop <= maxScrollY ) {\r\n                $el.scrollTop = correctedTop;\r\n                context.scrollTop = correctedTop;\r\n            }\r\n        })\r\n    }\r\n\r\n    context.autoScroll = function() {\r\n        var elapsed;\r\n        var deltaY = 0, deltaX = 0, scrollX = 0, scrollY = 0;\r\n        var timeConstant = 325;\r\n\r\n        elapsed = utils.getTime() - context.timeStamp;\r\n\r\n        if ( context.amplitudeTop ) {\r\n            deltaY = -context.amplitudeTop * Math.exp(-elapsed / timeConstant);\r\n        }\r\n        if ( context.amplitudeLeft ) {\r\n            deltaX = -context.amplitudeLeft * Math.exp(-elapsed / timeConstant);\r\n        }\r\n\r\n        if ( deltaX > 0.5 || deltaX < -0.5 ) {\r\n            scrollX = deltaX;\r\n        } else {\r\n            scrollX = 0;\r\n        }\r\n\r\n        if ( deltaY > 0.5 || deltaY < -0.5 ) {\r\n            scrollY = deltaY;\r\n        } else {\r\n            scrollY = 0;\r\n        }\r\n\r\n        context.scroll(context.targetLeft + scrollX, context.targetTop + scrollY);\r\n\r\n        if ( scrollX !== 0 || scrollY !== 0 ) {\r\n            context.autoScrollTracker = requestAnimationFrame(context.autoScroll);\r\n        } else {\r\n            context.isAutoScrolling = false;\r\n            context.autoScrollTracker = null;\r\n        }\r\n    }\r\n\r\n    context.triggerAutoScroll = function (targetLeft, targetTop, amplitudeLeft, amplitudeTop) {\r\n        if ( amplitudeLeft !== 0 || amplitudeTop !== 0 ) {\r\n            context.cancelAutoScroll();\r\n\r\n            context.timeStamp = utils.getTime();\r\n            context.targetLeft = targetLeft;\r\n            context.targetTop = targetTop;\r\n            context.amplitudeLeft = amplitudeLeft;\r\n            context.amplitudeTop = amplitudeTop;\r\n\r\n            context.isAutoScrolling = true;\r\n            context.autoScrollTracker = requestAnimationFrame(context.autoScroll);\r\n        }\r\n    }\r\n\r\n    context.cancelAutoScroll = function () {\r\n        if ( context.isAutoScrolling ) {\r\n            cancelAnimationFrame(context.autoScrollTracker);\r\n            context.isAutoScrolling = false;\r\n            context.autoScrollTracker = null;\r\n        }\r\n    }\r\n\r\n    context.tap = function (e) {\r\n        context.pressed = true;\r\n        context.referenceX = utils.getPoint(e, context.hasTouch).x;\r\n        context.referenceY = utils.getPoint(e, context.hasTouch).y;\r\n\r\n        context.velocityTop = context.amplitudeTop = 0;\r\n        context.velocityLeft = context.amplitudeLeft = 0;\r\n\r\n        context.lastScrollTop = context.scrollTop;\r\n        context.lastScrollLeft = context.scrollLeft;\r\n\r\n        context.timeStamp = utils.getTime();\r\n\r\n        context.cancelAutoScroll();\r\n\r\n        context.$listener.addEventListener( 'mousemove', context.swipe, true );\r\n        context.$listener.addEventListener( 'mouseup', context.release, true );\r\n\r\n        if ( utils.preventDefaultException(e.target, context.userOptions.preventDefaultException) ) {\r\n            e.preventDefault();\r\n        }\r\n    }\r\n\r\n    context.swipe = function (e) {\r\n        var x, y, deltaX, deltaY;\r\n\r\n        if (context.pressed) {\r\n            x = utils.getPoint(e, context.hasTouch).x;\r\n            y = utils.getPoint(e, context.hasTouch).y;\r\n\r\n            deltaX = context.referenceX - x;\r\n            deltaY = context.referenceY - y;\r\n\r\n            if (deltaX > 2 || deltaX < -2) {\r\n                context.referenceX = x;\r\n            } else {\r\n                deltaX = 0;\r\n            }\r\n            if (deltaY > 2 || deltaY < -2) {\r\n                context.referenceY = y;\r\n            } else {\r\n                deltaY = 0;\r\n            }\r\n\r\n            context.topTracker();\r\n            context.leftTracker();\r\n\r\n            context.scroll( context.scrollLeft + deltaX, context.scrollTop + deltaY );\r\n        }\r\n    }\r\n\r\n    context.release = function() {\r\n        var targetLeft, targetTop, amplitudeLeft, amplitudeTop;\r\n\r\n        context.pressed = false;\r\n\r\n        context.topTracker();\r\n        context.leftTracker();\r\n\r\n        if (context.velocityLeft > 10 || context.velocityLeft < -10) {\r\n            amplitudeLeft = 0.8 * context.velocityLeft;\r\n            targetLeft = Math.round(context.scrollLeft + amplitudeLeft);\r\n        } else {\r\n            targetLeft = context.scrollLeft;\r\n        }\r\n        if (context.velocityTop > 10 || context.velocityTop < -10) {\r\n            amplitudeTop = 0.8 * context.velocityTop;\r\n            targetTop = Math.round(context.scrollTop + amplitudeTop);\r\n        } else {\r\n            targetTop = context.scrollTop;\r\n        }\r\n\r\n        context.triggerAutoScroll(targetLeft, targetTop, amplitudeLeft, amplitudeTop);\r\n\r\n        context.$listener.removeEventListener( 'mousemove', context.swipe );\r\n        context.$listener.removeEventListener( 'mouseup', context.release );\r\n    }\r\n\r\n    if ( ! context.hasTouch && context.userOptions.enableKinetics ) {\r\n        context.$listener.addEventListener( 'mousedown', context.tap, true );\r\n    }\r\n\r\n    context.$on('$destroy', function() {\r\n        context.$listener.removeEventListener( 'mousedown', context.tap );\r\n    });\r\n\r\n    var scrollGen = function (start, left, top) {\r\n        return function () {\r\n            var targetLeft = 0,\r\n                targetTop = 0,\r\n                amplitudeLeft = 0,\r\n                amplitudeTop = 0,\r\n                maxScroll = {};\r\n\r\n            if ( start ) {\r\n                targetLeft = left ? 0 : context.scrollLeft;\r\n                targetTop = top ? 0 : context.scrollTop;\r\n                amplitudeLeft = left ? -context.scrollLeft : 0;\r\n                amplitudeTop = top ? -context.scrollTop : 0;\r\n            } else {\r\n                maxScroll = utils.getMaxScroll(context.childNodes);\r\n\r\n                targetLeft = left ? maxScroll.left : context.scrollLeft;\r\n                targetTop = top ? maxScroll.top : context.scrollTop;\r\n                amplitudeLeft = left ? maxScroll.left - context.scrollLeft : 0;\r\n                amplitudeTop = top ? maxScroll.top - context.scrollTop : 0;\r\n            }\r\n\r\n            context.triggerAutoScroll(targetLeft, targetTop, amplitudeLeft, amplitudeTop);\r\n        }\r\n    }\r\n\r\n    var scrollToBy = function (addTo) {\r\n        return function (left, top) {\r\n            var maxScroll, numLeft, corrLeft, numTop, corrTop, targetLeft, targetTop, moveLeft, moveTop, amplitudeLeft, amplitudeTop;\r\n\r\n            maxScroll = utils.getMaxScroll(context.childNodes);\r\n\r\n            numLeft = parseInt(left);\r\n            numTop = parseInt(top);\r\n\r\n            corrLeft = isNaN( numLeft ) ? context.scrollLeft : (addTo ? numLeft + context.scrollLeft : numLeft);\r\n            corrTop = isNaN( numTop ) ? context.scrollTop : (addTo ? numTop + context.scrollTop : numTop);\r\n\r\n            targetLeft = corrLeft > maxScroll.left ? maxScroll.left : (corrLeft < 0 ? 0 : corrLeft);\r\n            targetTop = corrTop > maxScroll.top ? maxScroll.top : (corrTop < 0 ? 0 : corrTop);\r\n\r\n            moveLeft = context.scrollLeft - targetLeft !== 0 ? true : false;\r\n            moveTop = context.scrollTop - targetTop !== 0 ? true : false;\r\n\r\n            amplitudeLeft = moveLeft ? targetLeft - context.scrollLeft : 0;\r\n            amplitudeTop = moveTop ? targetTop - context.scrollTop : 0;\r\n\r\n            context.triggerAutoScroll(targetLeft, targetTop, amplitudeLeft, amplitudeTop);\r\n        }\r\n    }\r\n\r\n    var start = true,\r\n        notStart = false,\r\n        left = true,\r\n        notLeft = false,\r\n        top = true,\r\n        notTop = false,\r\n        toValue = false,\r\n        byValue = true;\r\n\r\n    context.exposedMethods = {\r\n        scrollToStart: scrollGen(start, left, top),\r\n        scrollToStartLeft: scrollGen(start, left, notTop),\r\n        scrollToStartTop: scrollGen(start, notLeft, top),\r\n        scrollToEnd: scrollGen(notStart, left, top),\r\n        scrollToEndLeft: scrollGen(notStart, left, notTop),\r\n        scrollToEndTop: scrollGen(notStart, notLeft, top),\r\n        scrollToPosition: scrollToBy(toValue),\r\n        scrollByValue: scrollToBy(byValue)\r\n    }\r\n}\r\n\r\nmodule.exports = KineticEngine;\r\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\n\r\nfunction KineticScroll (augNsUtils, augNsOptions, kineticEngine) {\r\n    return {\r\n        restrict: 'E',\r\n        scope: {\r\n            options: '='\r\n        },\r\n        transclude: true,\r\n        replace: true,\r\n        template: '<span data-name=\"kinetic-scroll\" ng-transclude></span>',\r\n        link: function (scope, element) {\r\n            scope.hasTouch = 'ontouchstart' in window;\r\n            scope.DETECT_EVT = scope.hasTouch ? 'touchstart' : 'mouseover';\r\n            scope.$listener = element[0];\r\n            scope.childNodes = [ scope.$listener ];\r\n\r\n            scope.userOptions = angular.extend({}, augNsOptions, scope.options);\r\n\r\n            kineticEngine.call(this, scope, augNsUtils);\r\n\r\n            // expose few methods to the parent controller\r\n            if ( scope.userOptions.hasOwnProperty('name') ) {\r\n                scope.$parent[scope.userOptions.name] = scope.exposedMethods;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nKineticScroll.$inject = ['augNsUtils', 'augNsOptions', 'kineticEngine'];\r\n\r\nmodule.exports = KineticScroll;\r\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\n\r\nfunction ScrollArea () {\r\n    return {\r\n        require: '^^connectScrolls',\r\n        restrict: 'E',\r\n        transclude: true,\r\n        replace: true,\r\n        template: '<span  data-name=\"scroll-area\" ng-transclude></span>',\r\n        link: function (scope, element, attrs, connectScrollsCtrl) {\r\n            element.attr( 'id', 'PARTICIPATING_NODE_' + Math.random().toString().substring(2, 15) );\r\n            connectScrollsCtrl.addScrollArea(element[0]);\r\n        }\r\n    }\r\n}\r\n\r\nmodule.exports = ScrollArea;\r\n\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports) {\n\nmodule.exports = angular;\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\n\r\nvar angular = __webpack_require__(6);\r\n\r\nangular.module('ngAugmentNativeScroll', [])\r\n    .factory('augNsUtils', __webpack_require__(1))\r\n    .value('augNsOptions', __webpack_require__(0))\r\n    .value('kineticEngine', __webpack_require__(3))\r\n    .directive('connectScrolls', __webpack_require__(2))\r\n    .directive('scrollArea', __webpack_require__(5))\r\n    .directive('kineticScroll', __webpack_require__(4));\r\n\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// ngAugmentNativeScroll.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 7);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 845f6d34b4c6f67f10f7","'use strict';\r\n\r\nvar augNsOptions = {\r\n    enableKinetics: true,\r\n    movingAverage: 0.1,\r\n    preventDefaultException: {\r\n        tagName: /^(INPUT|TEXTAREA|BUTTON|SELECT)$/\r\n    }\r\n}\r\n\r\nmodule.exports = augNsOptions;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/augNsOptions.value.js\n// module id = 0\n// module chunks = 0","function augNsUtils () {\r\n     /*eslint-disable angular/window-service, angular/timeout-service */\r\n    (function() {\r\n        var lastTime = 0;\r\n        var vendors = ['ms', 'moz', 'webkit', 'o'];\r\n        for(var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {\r\n            window.requestAnimationFrame = window[vendors[x]+'RequestAnimationFrame'];\r\n            window.cancelAnimationFrame = window[vendors[x]+'CancelAnimationFrame'] || window[vendors[x]+'CancelRequestAnimationFrame'];\r\n        }\r\n\r\n        if ( ! window.requestAnimationFrame ) {\r\n            window.requestAnimationFrame = function(callback) {\r\n                var currTime = new Date().getTime();\r\n                var timeToCall = Math.max(0, 16 - (currTime - lastTime));\r\n                var id = window.setTimeout(function() {\r\n                    callback(currTime + timeToCall);\r\n                }, timeToCall);\r\n                lastTime = currTime + timeToCall;\r\n                return id;\r\n            };\r\n        }\r\n\r\n        if ( ! window.cancelAnimationFrame ) {\r\n            window.cancelAnimationFrame = function(id) {\r\n                clearTimeout(id);\r\n            }\r\n        }\r\n    }());\r\n\r\n    return {\r\n        findMatchingTarget: function (target, nodes) {\r\n            var found;\r\n\r\n            if ( ! nodes.length || target.tagName === 'BODY' ) {\r\n                return 'BODY';\r\n            }\r\n\r\n            found = nodes.find(function (node) {\r\n                return node.id === target.id\r\n            });\r\n\r\n            if ( found ) {\r\n                return target.id;\r\n            } else {\r\n                return this.findMatchingTarget(target.parentElement, nodes);\r\n            }\r\n        },\r\n        getPoint: function (e, hasTouch) {\r\n            var point;\r\n\r\n            if( hasTouch && event.touches.length ) {\r\n                point = {\r\n                    x : event.touches[0].clientX,\r\n                    y : event.touches[0].clientY\r\n                }\r\n            } else {\r\n                point = {\r\n                    x : event.clientX,\r\n                    y : event.clientY\r\n                }\r\n            }\r\n\r\n            return point;\r\n        },\r\n        getTime: Date.now || function getTime () {\r\n            return new Date().utils.getTime();\r\n        },\r\n        preventDefaultException: function (el, exceptions) {\r\n            for ( var i in exceptions ) {\r\n                if ( exceptions[i].test(el[i]) ) {\r\n                    return true;\r\n                }\r\n            }\r\n\r\n            return false;\r\n        },\r\n        getMaxScroll: function (nodes) {\r\n            var maxScrollLeft = 0,\r\n                maxScrollTop = 0;\r\n\r\n            nodes.forEach(function (node) {\r\n                var $el = node.children[0];\r\n                var maxScrollX = $el.scrollWidth - $el.clientWidth;\r\n                var maxScrollY = $el.scrollHeight - $el.clientHeight;\r\n\r\n                if ( maxScrollX > maxScrollLeft ) {\r\n                    maxScrollLeft = maxScrollX;\r\n                }\r\n                if ( maxScrollY > maxScrollTop ) {\r\n                    maxScrollTop = maxScrollY;\r\n                }\r\n            });\r\n\r\n            return {\r\n                left: maxScrollLeft,\r\n                top: maxScrollTop\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nmodule.exports = augNsUtils;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/augNsUtils.factory.js\n// module id = 1\n// module chunks = 0","'use strict';\r\n\r\nfunction ConnectScrolls (augNsUtils, augNsOptions, kineticEngine) {\r\n    return {\r\n        restrict: 'E',\r\n        scope: {\r\n            options: '='\r\n        },\r\n        transclude: true,\r\n        replace: true,\r\n        template: '<span data-name=\"conntect-scroll\" ng-transclude></span>',\r\n        link: function (scope, element) {\r\n            scope.hasTouch = 'ontouchstart' in window;\r\n            scope.DETECT_EVT = scope.hasTouch ? 'touchstart' : 'mouseover';\r\n            scope.activeId = undefined;\r\n            scope.$listener = element[0];\r\n\r\n            scope.userOptions = angular.extend({}, augNsOptions, scope.options);\r\n\r\n            kineticEngine.call(this, scope, augNsUtils);\r\n\r\n            scope.setActiveNode = function (e) {\r\n                scope.activeId = augNsUtils.findMatchingTarget(e.target, scope.childNodes);\r\n\r\n                // if its a touch device and we are autoscrolling\r\n                // it should stop as soon as the user touches the scroll area\r\n                // else there will be jerky effects\r\n                if ( scope.hasTouch ) {\r\n                    scope.cancelAutoScroll();\r\n                }\r\n            }\r\n\r\n            scope.onScroll = function (e) {\r\n                var target = e.target;\r\n                var valX = undefined;\r\n                var valY = undefined;\r\n\r\n                if ( scope.pressed || scope.isAutoScrolling ) {\r\n                    e.preventDefault();\r\n                    e.stopPropagation();\r\n                    return;\r\n                }\r\n\r\n                if ( target.clientWidth !== target.scrollWidth ) {\r\n                    valX = target.scrollLeft;\r\n                    scope.lastScrollLeft = scope.scrollLeft;\r\n                    scope.scrollLeft = valX;\r\n                } else {\r\n                    valX = scope.scrollLeft;\r\n                }\r\n                if ( target.clientHeight !== target.scrollHeight ) {\r\n                    valY = target.scrollTop;\r\n                    scope.lastScrollTop = scope.scrollTop;\r\n                    scope.scrollTop = valY;\r\n                } else {\r\n                    valY = scope.scrollTop;\r\n                }\r\n\r\n                scope.childNodes.forEach(function(node) {\r\n                    if ( node.id !== scope.activeId ) {\r\n                        node.children[0].scrollLeft = valX;\r\n                        node.children[0].scrollTop = valY;\r\n                    }\r\n                });\r\n            }\r\n\r\n            scope.$listener.addEventListener( scope.DETECT_EVT, scope.setActiveNode, true );\r\n            scope.$listener.addEventListener( 'scroll', scope.onScroll, true );\r\n\r\n            scope.$on('$destroy', function() {\r\n                scope.$listener.removeEventListener( scope.DETECT_EVT, scope.setActiveNode );\r\n                scope.$listener.removeEventListener( 'scroll', scope.onScroll );\r\n            });\r\n\r\n            // expose few methods to the parent controller\r\n            if ( scope.userOptions.hasOwnProperty('name') ) {\r\n                scope.$parent[scope.userOptions.name] = scope.exposedMethods;\r\n            }\r\n        },\r\n        controller: ['$scope', function connectScrollsCtrl($scope) {\r\n            var childNodes = $scope.childNodes = [];\r\n\r\n            this.addScrollArea = function (node) {\r\n                childNodes.push(node);\r\n            }\r\n        }]\r\n    }\r\n}\r\n\r\nConnectScrolls.$inject = ['augNsUtils', 'augNsOptions', 'kineticEngine'];\r\n\r\nmodule.exports = ConnectScrolls;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/connectScrolls.directive.js\n// module id = 2\n// module chunks = 0","'use strict';\r\n\r\nfunction KineticEngine (context, utils) {\r\n    context.scrollLeft = 0;\r\n    context.scrollTop = 0;\r\n    context.lastScrollLeft = 0;\r\n    context.lastScrollTop = 0;\r\n    context.targetTop = 0;\r\n    context.targetLeft = 0;\r\n\r\n    context.velocityTop = 0;\r\n    context.velocityLeft = 0;\r\n    context.amplitudeTop = 0;\r\n    context.amplitudeLeft = 0;\r\n\r\n    context.timeStamp = 0;\r\n    context.referenceX = 0;\r\n    context.referenceY = 0;\r\n    context.pressed = false;\r\n    context.autoScrollTracker = null;\r\n    context.isAutoScrolling = false;\r\n\r\n    context.leftTracker = function () {\r\n        var now, elapsed, delta;\r\n\r\n        now = utils.getTime();\r\n        elapsed = now - context.timeStamp;\r\n        context.timeStamp = now;\r\n        delta = context.scrollLeft - context.lastScrollLeft;\r\n        context.lastScrollLeft = context.scrollLeft;\r\n\r\n        context.velocityLeft = context.userOptions.movingAverage * (1000 * delta / (1 + elapsed)) + 0.2 * context.velocityLeft;\r\n    }\r\n\r\n    context.topTracker = function () {\r\n        var now, elapsed, delta;\r\n\r\n        now = utils.getTime();\r\n        elapsed = now - context.timeStamp;\r\n        context.timeStamp = now;\r\n        delta = context.scrollTop - context.lastScrollTop;\r\n        context.lastScrollTop = context.scrollTop;\r\n\r\n        context.velocityTop = context.userOptions.movingAverage * (1000 * delta / (1 + elapsed)) + 0.2 * context.velocityTop;\r\n    }\r\n\r\n    context.scroll = function(left, top) {\r\n        var correctedLeft = Math.round(left);\r\n        var correctedTop = Math.round(top);\r\n\r\n        context.childNodes.forEach(function(node) {\r\n            var $el = node.children[0];\r\n            var maxScrollX = $el.scrollWidth - $el.clientWidth;\r\n            var maxScrollY = $el.scrollHeight - $el.clientHeight;\r\n\r\n            if ( maxScrollX > 0 && correctedLeft >= 0 && correctedLeft <= maxScrollX ) {\r\n                $el.scrollLeft = correctedLeft;\r\n                context.scrollLeft = correctedLeft;\r\n            }\r\n            if ( maxScrollY > 0 && correctedTop >= 0 && correctedTop <= maxScrollY ) {\r\n                $el.scrollTop = correctedTop;\r\n                context.scrollTop = correctedTop;\r\n            }\r\n        })\r\n    }\r\n\r\n    context.autoScroll = function() {\r\n        var elapsed;\r\n        var deltaY = 0, deltaX = 0, scrollX = 0, scrollY = 0;\r\n        var timeConstant = 325;\r\n\r\n        elapsed = utils.getTime() - context.timeStamp;\r\n\r\n        if ( context.amplitudeTop ) {\r\n            deltaY = -context.amplitudeTop * Math.exp(-elapsed / timeConstant);\r\n        }\r\n        if ( context.amplitudeLeft ) {\r\n            deltaX = -context.amplitudeLeft * Math.exp(-elapsed / timeConstant);\r\n        }\r\n\r\n        if ( deltaX > 0.5 || deltaX < -0.5 ) {\r\n            scrollX = deltaX;\r\n        } else {\r\n            scrollX = 0;\r\n        }\r\n\r\n        if ( deltaY > 0.5 || deltaY < -0.5 ) {\r\n            scrollY = deltaY;\r\n        } else {\r\n            scrollY = 0;\r\n        }\r\n\r\n        context.scroll(context.targetLeft + scrollX, context.targetTop + scrollY);\r\n\r\n        if ( scrollX !== 0 || scrollY !== 0 ) {\r\n            context.autoScrollTracker = requestAnimationFrame(context.autoScroll);\r\n        } else {\r\n            context.isAutoScrolling = false;\r\n            context.autoScrollTracker = null;\r\n        }\r\n    }\r\n\r\n    context.triggerAutoScroll = function (targetLeft, targetTop, amplitudeLeft, amplitudeTop) {\r\n        if ( amplitudeLeft !== 0 || amplitudeTop !== 0 ) {\r\n            context.cancelAutoScroll();\r\n\r\n            context.timeStamp = utils.getTime();\r\n            context.targetLeft = targetLeft;\r\n            context.targetTop = targetTop;\r\n            context.amplitudeLeft = amplitudeLeft;\r\n            context.amplitudeTop = amplitudeTop;\r\n\r\n            context.isAutoScrolling = true;\r\n            context.autoScrollTracker = requestAnimationFrame(context.autoScroll);\r\n        }\r\n    }\r\n\r\n    context.cancelAutoScroll = function () {\r\n        if ( context.isAutoScrolling ) {\r\n            cancelAnimationFrame(context.autoScrollTracker);\r\n            context.isAutoScrolling = false;\r\n            context.autoScrollTracker = null;\r\n        }\r\n    }\r\n\r\n    context.tap = function (e) {\r\n        context.pressed = true;\r\n        context.referenceX = utils.getPoint(e, context.hasTouch).x;\r\n        context.referenceY = utils.getPoint(e, context.hasTouch).y;\r\n\r\n        context.velocityTop = context.amplitudeTop = 0;\r\n        context.velocityLeft = context.amplitudeLeft = 0;\r\n\r\n        context.lastScrollTop = context.scrollTop;\r\n        context.lastScrollLeft = context.scrollLeft;\r\n\r\n        context.timeStamp = utils.getTime();\r\n\r\n        context.cancelAutoScroll();\r\n\r\n        context.$listener.addEventListener( 'mousemove', context.swipe, true );\r\n        context.$listener.addEventListener( 'mouseup', context.release, true );\r\n\r\n        if ( utils.preventDefaultException(e.target, context.userOptions.preventDefaultException) ) {\r\n            e.preventDefault();\r\n        }\r\n    }\r\n\r\n    context.swipe = function (e) {\r\n        var x, y, deltaX, deltaY;\r\n\r\n        if (context.pressed) {\r\n            x = utils.getPoint(e, context.hasTouch).x;\r\n            y = utils.getPoint(e, context.hasTouch).y;\r\n\r\n            deltaX = context.referenceX - x;\r\n            deltaY = context.referenceY - y;\r\n\r\n            if (deltaX > 2 || deltaX < -2) {\r\n                context.referenceX = x;\r\n            } else {\r\n                deltaX = 0;\r\n            }\r\n            if (deltaY > 2 || deltaY < -2) {\r\n                context.referenceY = y;\r\n            } else {\r\n                deltaY = 0;\r\n            }\r\n\r\n            context.topTracker();\r\n            context.leftTracker();\r\n\r\n            context.scroll( context.scrollLeft + deltaX, context.scrollTop + deltaY );\r\n        }\r\n    }\r\n\r\n    context.release = function() {\r\n        var targetLeft, targetTop, amplitudeLeft, amplitudeTop;\r\n\r\n        context.pressed = false;\r\n\r\n        context.topTracker();\r\n        context.leftTracker();\r\n\r\n        if (context.velocityLeft > 10 || context.velocityLeft < -10) {\r\n            amplitudeLeft = 0.8 * context.velocityLeft;\r\n            targetLeft = Math.round(context.scrollLeft + amplitudeLeft);\r\n        } else {\r\n            targetLeft = context.scrollLeft;\r\n        }\r\n        if (context.velocityTop > 10 || context.velocityTop < -10) {\r\n            amplitudeTop = 0.8 * context.velocityTop;\r\n            targetTop = Math.round(context.scrollTop + amplitudeTop);\r\n        } else {\r\n            targetTop = context.scrollTop;\r\n        }\r\n\r\n        context.triggerAutoScroll(targetLeft, targetTop, amplitudeLeft, amplitudeTop);\r\n\r\n        context.$listener.removeEventListener( 'mousemove', context.swipe );\r\n        context.$listener.removeEventListener( 'mouseup', context.release );\r\n    }\r\n\r\n    if ( ! context.hasTouch && context.userOptions.enableKinetics ) {\r\n        context.$listener.addEventListener( 'mousedown', context.tap, true );\r\n    }\r\n\r\n    context.$on('$destroy', function() {\r\n        context.$listener.removeEventListener( 'mousedown', context.tap );\r\n    });\r\n\r\n    var scrollGen = function (start, left, top) {\r\n        return function () {\r\n            var targetLeft = 0,\r\n                targetTop = 0,\r\n                amplitudeLeft = 0,\r\n                amplitudeTop = 0,\r\n                maxScroll = {};\r\n\r\n            if ( start ) {\r\n                targetLeft = left ? 0 : context.scrollLeft;\r\n                targetTop = top ? 0 : context.scrollTop;\r\n                amplitudeLeft = left ? -context.scrollLeft : 0;\r\n                amplitudeTop = top ? -context.scrollTop : 0;\r\n            } else {\r\n                maxScroll = utils.getMaxScroll(context.childNodes);\r\n\r\n                targetLeft = left ? maxScroll.left : context.scrollLeft;\r\n                targetTop = top ? maxScroll.top : context.scrollTop;\r\n                amplitudeLeft = left ? maxScroll.left - context.scrollLeft : 0;\r\n                amplitudeTop = top ? maxScroll.top - context.scrollTop : 0;\r\n            }\r\n\r\n            context.triggerAutoScroll(targetLeft, targetTop, amplitudeLeft, amplitudeTop);\r\n        }\r\n    }\r\n\r\n    var scrollToBy = function (addTo) {\r\n        return function (left, top) {\r\n            var maxScroll, numLeft, corrLeft, numTop, corrTop, targetLeft, targetTop, moveLeft, moveTop, amplitudeLeft, amplitudeTop;\r\n\r\n            maxScroll = utils.getMaxScroll(context.childNodes);\r\n\r\n            numLeft = parseInt(left);\r\n            numTop = parseInt(top);\r\n\r\n            corrLeft = isNaN( numLeft ) ? context.scrollLeft : (addTo ? numLeft + context.scrollLeft : numLeft);\r\n            corrTop = isNaN( numTop ) ? context.scrollTop : (addTo ? numTop + context.scrollTop : numTop);\r\n\r\n            targetLeft = corrLeft > maxScroll.left ? maxScroll.left : (corrLeft < 0 ? 0 : corrLeft);\r\n            targetTop = corrTop > maxScroll.top ? maxScroll.top : (corrTop < 0 ? 0 : corrTop);\r\n\r\n            moveLeft = context.scrollLeft - targetLeft !== 0 ? true : false;\r\n            moveTop = context.scrollTop - targetTop !== 0 ? true : false;\r\n\r\n            amplitudeLeft = moveLeft ? targetLeft - context.scrollLeft : 0;\r\n            amplitudeTop = moveTop ? targetTop - context.scrollTop : 0;\r\n\r\n            context.triggerAutoScroll(targetLeft, targetTop, amplitudeLeft, amplitudeTop);\r\n        }\r\n    }\r\n\r\n    var start = true,\r\n        notStart = false,\r\n        left = true,\r\n        notLeft = false,\r\n        top = true,\r\n        notTop = false,\r\n        toValue = false,\r\n        byValue = true;\r\n\r\n    context.exposedMethods = {\r\n        scrollToStart: scrollGen(start, left, top),\r\n        scrollToStartLeft: scrollGen(start, left, notTop),\r\n        scrollToStartTop: scrollGen(start, notLeft, top),\r\n        scrollToEnd: scrollGen(notStart, left, top),\r\n        scrollToEndLeft: scrollGen(notStart, left, notTop),\r\n        scrollToEndTop: scrollGen(notStart, notLeft, top),\r\n        scrollToPosition: scrollToBy(toValue),\r\n        scrollByValue: scrollToBy(byValue)\r\n    }\r\n}\r\n\r\nmodule.exports = KineticEngine;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/kineticEngine.value.js\n// module id = 3\n// module chunks = 0","'use strict';\r\n\r\nfunction KineticScroll (augNsUtils, augNsOptions, kineticEngine) {\r\n    return {\r\n        restrict: 'E',\r\n        scope: {\r\n            options: '='\r\n        },\r\n        transclude: true,\r\n        replace: true,\r\n        template: '<span data-name=\"kinetic-scroll\" ng-transclude></span>',\r\n        link: function (scope, element) {\r\n            scope.hasTouch = 'ontouchstart' in window;\r\n            scope.DETECT_EVT = scope.hasTouch ? 'touchstart' : 'mouseover';\r\n            scope.$listener = element[0];\r\n            scope.childNodes = [ scope.$listener ];\r\n\r\n            scope.userOptions = angular.extend({}, augNsOptions, scope.options);\r\n\r\n            kineticEngine.call(this, scope, augNsUtils);\r\n\r\n            // expose few methods to the parent controller\r\n            if ( scope.userOptions.hasOwnProperty('name') ) {\r\n                scope.$parent[scope.userOptions.name] = scope.exposedMethods;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nKineticScroll.$inject = ['augNsUtils', 'augNsOptions', 'kineticEngine'];\r\n\r\nmodule.exports = KineticScroll;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/kineticScroll.directive.js\n// module id = 4\n// module chunks = 0","'use strict';\r\n\r\nfunction ScrollArea () {\r\n    return {\r\n        require: '^^connectScrolls',\r\n        restrict: 'E',\r\n        transclude: true,\r\n        replace: true,\r\n        template: '<span  data-name=\"scroll-area\" ng-transclude></span>',\r\n        link: function (scope, element, attrs, connectScrollsCtrl) {\r\n            element.attr( 'id', 'PARTICIPATING_NODE_' + Math.random().toString().substring(2, 15) );\r\n            connectScrollsCtrl.addScrollArea(element[0]);\r\n        }\r\n    }\r\n}\r\n\r\nmodule.exports = ScrollArea;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/scrollArea.directive.js\n// module id = 5\n// module chunks = 0","module.exports = angular;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"angular\"\n// module id = 6\n// module chunks = 0","'use strict';\r\n\r\nvar angular = require('angular');\r\n\r\nangular.module('ngAugmentNativeScroll', [])\r\n    .factory('augNsUtils', require('./augNsUtils.factory.js'))\r\n    .value('augNsOptions', require('./augNsOptions.value.js'))\r\n    .value('kineticEngine', require('./kineticEngine.value.js'))\r\n    .directive('connectScrolls', require('./connectScrolls.directive.js'))\r\n    .directive('scrollArea', require('./scrollArea.directive.js'))\r\n    .directive('kineticScroll', require('./kineticScroll.directive.js'));\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/index.js\n// module id = 7\n// module chunks = 0"],"sourceRoot":""}