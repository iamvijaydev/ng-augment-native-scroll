{"version":3,"sources":["webpack:///./dist/ngAugmentNativeScroll.min.js","webpack:///webpack/bootstrap 541487ee3ec4b219c758","webpack:///./src/index.js","webpack:///external \"angular\"","webpack:///./src/augNsUtils.factory.js","webpack:///./src/augNsOptions.value.js","webpack:///./src/kineticEngine.value.js","webpack:///./src/connectScrolls.directive.js","webpack:///./src/scrollArea.directive.js","webpack:///./src/kineticScroll.directive.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","angular","factory","value","directive","augNsUtils","lastTime","vendors","x","length","window","requestAnimationFrame","cancelAnimationFrame","callback","currTime","Date","getTime","timeToCall","Math","max","setTimeout","clearTimeout","findMatchingTarget","target","nodes","found","tagName","find","node","this","parentElement","getPoint","e","hasTouch","point","event","touches","clientX","y","clientY","now","utils","preventDefaultException","el","exceptions","i","test","getMaxScroll","maxScrollLeft","maxScrollTop","forEach","$el","children","maxScrollX","scrollWidth","clientWidth","maxScrollY","scrollHeight","clientHeight","left","top","augNsOptions","enableKinetics","movingAverage","KineticEngine","context","scrollLeft","scrollTop","lastScrollLeft","lastScrollTop","targetTop","targetLeft","velocityTop","velocityLeft","amplitudeTop","amplitudeLeft","timeStamp","referenceX","referenceY","pressed","autoScrollTracker","isAutoScrolling","leftTracker","elapsed","delta","userOptions","topTracker","scroll","correctedLeft","round","correctedTop","childNodes","autoScroll","deltaY","deltaX","scrollX","scrollY","timeConstant","exp","triggerAutoScroll","cancelAutoScroll","tap","$listener","addEventListener","swipe","release","preventDefault","removeEventListener","$on","scrollGen","start","maxScroll","scrollToBy","addTo","numLeft","corrLeft","numTop","corrTop","moveLeft","moveTop","parseInt","isNaN","notStart","notLeft","notTop","toValue","byValue","exposedMethods","scrollToStart","scrollToStartLeft","scrollToStartTop","scrollToEnd","scrollToEndLeft","scrollToEndTop","scrollToPosition","scrollByValue","ConnectScrolls","kineticEngine","restrict","scope","options","transclude","replace","template","link","element","DETECT_EVT","activeId","undefined","extend","setActiveNode","onScroll","stopPropagation","valX","valY","$parent","augNs","controller","$scope","addScrollArea","push","$inject","ScrollArea","require","attrs","connectScrollsCtrl","attr","random","toString","substring","KineticScroll"],"mappings":"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","file":"E:\\works\\ng-augment-native-scroll/dist/ngAugmentNativeScroll.min.js","sourcesContent":["/*!\n * v0.11.0\n * \n * MIT License\r\n * \r\n * Copyright (c) 2017 Vijay Dev (http://vijaydev.com/)\r\n * \r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n * \r\n * The above copyright notice and this permission notice shall be included in all\r\n * copies or substantial portions of the Software.\r\n * \r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n * SOFTWARE.\r\n * \n */\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar angular = __webpack_require__(1);\n\t\n\tangular.module('ngAugmentNativeScroll', []).factory('augNsUtils', __webpack_require__(2)).value('augNsOptions', __webpack_require__(3)).value('kineticEngine', __webpack_require__(4)).directive('connectScrolls', __webpack_require__(5)).directive('scrollArea', __webpack_require__(6)).directive('kineticScroll', __webpack_require__(7));\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\tmodule.exports = angular;\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\tfunction augNsUtils() {\n\t    /*eslint-disable angular/window-service, angular/timeout-service */\n\t    (function () {\n\t        var lastTime = 0;\n\t        var vendors = ['ms', 'moz', 'webkit', 'o'];\n\t        for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {\n\t            window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];\n\t            window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] || window[vendors[x] + 'CancelRequestAnimationFrame'];\n\t        }\n\t\n\t        if (!window.requestAnimationFrame) {\n\t            window.requestAnimationFrame = function (callback) {\n\t                var currTime = new Date().getTime();\n\t                var timeToCall = Math.max(0, 16 - (currTime - lastTime));\n\t                var id = window.setTimeout(function () {\n\t                    callback(currTime + timeToCall);\n\t                }, timeToCall);\n\t                lastTime = currTime + timeToCall;\n\t                return id;\n\t            };\n\t        }\n\t\n\t        if (!window.cancelAnimationFrame) {\n\t            window.cancelAnimationFrame = function (id) {\n\t                clearTimeout(id);\n\t            };\n\t        }\n\t    })();\n\t\n\t    return {\n\t        findMatchingTarget: function (target, nodes) {\n\t            var found;\n\t\n\t            if (!nodes.length || target.tagName === 'BODY') {\n\t                return 'BODY';\n\t            }\n\t\n\t            found = nodes.find(function (node) {\n\t                return node.id === target.id;\n\t            });\n\t\n\t            if (found) {\n\t                return target.id;\n\t            } else {\n\t                return this.findMatchingTarget(target.parentElement, nodes);\n\t            }\n\t        },\n\t        getPoint: function (e, hasTouch) {\n\t            var point;\n\t\n\t            if (hasTouch && event.touches.length) {\n\t                point = {\n\t                    x: event.touches[0].clientX,\n\t                    y: event.touches[0].clientY\n\t                };\n\t            } else {\n\t                point = {\n\t                    x: event.clientX,\n\t                    y: event.clientY\n\t                };\n\t            }\n\t\n\t            return point;\n\t        },\n\t        getTime: Date.now || function getTime() {\n\t            return new Date().utils.getTime();\n\t        },\n\t        preventDefaultException: function (el, exceptions) {\n\t            for (var i in exceptions) {\n\t                if (exceptions[i].test(el[i])) {\n\t                    return true;\n\t                }\n\t            }\n\t\n\t            return false;\n\t        },\n\t        getMaxScroll: function (nodes) {\n\t            var maxScrollLeft = 0,\n\t                maxScrollTop = 0;\n\t\n\t            nodes.forEach(function (node) {\n\t                var $el = node.children[0];\n\t                var maxScrollX = $el.scrollWidth - $el.clientWidth;\n\t                var maxScrollY = $el.scrollHeight - $el.clientHeight;\n\t\n\t                if (maxScrollX > maxScrollLeft) {\n\t                    maxScrollLeft = maxScrollX;\n\t                }\n\t                if (maxScrollY > maxScrollTop) {\n\t                    maxScrollTop = maxScrollY;\n\t                }\n\t            });\n\t\n\t            return {\n\t                left: maxScrollLeft,\n\t                top: maxScrollTop\n\t            };\n\t        }\n\t    };\n\t}\n\t\n\tmodule.exports = augNsUtils;\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tvar augNsOptions = {\n\t    enableKinetics: true,\n\t    movingAverage: 0.1,\n\t    preventDefaultException: {\n\t        tagName: /^(INPUT|TEXTAREA|BUTTON|SELECT)$/\n\t    }\n\t};\n\t\n\tmodule.exports = augNsOptions;\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tfunction KineticEngine(context, utils) {\n\t    context.scrollLeft = 0;\n\t    context.scrollTop = 0;\n\t    context.lastScrollLeft = 0;\n\t    context.lastScrollTop = 0;\n\t    context.targetTop = 0;\n\t    context.targetLeft = 0;\n\t\n\t    context.velocityTop = 0;\n\t    context.velocityLeft = 0;\n\t    context.amplitudeTop = 0;\n\t    context.amplitudeLeft = 0;\n\t\n\t    context.timeStamp = 0;\n\t    context.referenceX = 0;\n\t    context.referenceY = 0;\n\t    context.pressed = false;\n\t    context.autoScrollTracker = null;\n\t    context.isAutoScrolling = false;\n\t\n\t    context.leftTracker = function () {\n\t        var now, elapsed, delta;\n\t\n\t        now = utils.getTime();\n\t        elapsed = now - context.timeStamp;\n\t        context.timeStamp = now;\n\t        delta = context.scrollLeft - context.lastScrollLeft;\n\t        context.lastScrollLeft = context.scrollLeft;\n\t\n\t        context.velocityLeft = context.userOptions.movingAverage * (1000 * delta / (1 + elapsed)) + 0.2 * context.velocityLeft;\n\t    };\n\t\n\t    context.topTracker = function () {\n\t        var now, elapsed, delta;\n\t\n\t        now = utils.getTime();\n\t        elapsed = now - context.timeStamp;\n\t        context.timeStamp = now;\n\t        delta = context.scrollTop - context.lastScrollTop;\n\t        context.lastScrollTop = context.scrollTop;\n\t\n\t        context.velocityTop = context.userOptions.movingAverage * (1000 * delta / (1 + elapsed)) + 0.2 * context.velocityTop;\n\t    };\n\t\n\t    context.scroll = function (left, top) {\n\t        var correctedLeft = Math.round(left);\n\t        var correctedTop = Math.round(top);\n\t\n\t        context.childNodes.forEach(function (node) {\n\t            var $el = node.children[0];\n\t            var maxScrollX = $el.scrollWidth - $el.clientWidth;\n\t            var maxScrollY = $el.scrollHeight - $el.clientHeight;\n\t\n\t            if (maxScrollX > 0 && correctedLeft >= 0 && correctedLeft <= maxScrollX) {\n\t                $el.scrollLeft = correctedLeft;\n\t                context.scrollLeft = correctedLeft;\n\t            }\n\t            if (maxScrollY > 0 && correctedTop >= 0 && correctedTop <= maxScrollY) {\n\t                $el.scrollTop = correctedTop;\n\t                context.scrollTop = correctedTop;\n\t            }\n\t        });\n\t    };\n\t\n\t    context.autoScroll = function () {\n\t        var elapsed;\n\t        var deltaY = 0,\n\t            deltaX = 0,\n\t            scrollX = 0,\n\t            scrollY = 0;\n\t        var timeConstant = 325;\n\t\n\t        elapsed = utils.getTime() - context.timeStamp;\n\t\n\t        if (context.amplitudeTop) {\n\t            deltaY = -context.amplitudeTop * Math.exp(-elapsed / timeConstant);\n\t        }\n\t        if (context.amplitudeLeft) {\n\t            deltaX = -context.amplitudeLeft * Math.exp(-elapsed / timeConstant);\n\t        }\n\t\n\t        if (deltaX > 0.5 || deltaX < -0.5) {\n\t            scrollX = deltaX;\n\t        } else {\n\t            scrollX = 0;\n\t        }\n\t\n\t        if (deltaY > 0.5 || deltaY < -0.5) {\n\t            scrollY = deltaY;\n\t        } else {\n\t            scrollY = 0;\n\t        }\n\t\n\t        context.scroll(context.targetLeft + scrollX, context.targetTop + scrollY);\n\t\n\t        if (scrollX !== 0 || scrollY !== 0) {\n\t            context.autoScrollTracker = requestAnimationFrame(context.autoScroll);\n\t        } else {\n\t            context.isAutoScrolling = false;\n\t            context.autoScrollTracker = null;\n\t        }\n\t    };\n\t\n\t    context.triggerAutoScroll = function (targetLeft, targetTop, amplitudeLeft, amplitudeTop) {\n\t        if (amplitudeLeft !== 0 || amplitudeTop !== 0) {\n\t            context.cancelAutoScroll();\n\t\n\t            context.timeStamp = utils.getTime();\n\t            context.targetLeft = targetLeft;\n\t            context.targetTop = targetTop;\n\t            context.amplitudeLeft = amplitudeLeft;\n\t            context.amplitudeTop = amplitudeTop;\n\t\n\t            context.isAutoScrolling = true;\n\t            context.autoScrollTracker = requestAnimationFrame(context.autoScroll);\n\t        }\n\t    };\n\t\n\t    context.cancelAutoScroll = function () {\n\t        if (context.isAutoScrolling) {\n\t            cancelAnimationFrame(context.autoScrollTracker);\n\t            context.isAutoScrolling = false;\n\t            context.autoScrollTracker = null;\n\t        }\n\t    };\n\t\n\t    context.tap = function (e) {\n\t        context.pressed = true;\n\t        context.referenceX = utils.getPoint(e, context.hasTouch).x;\n\t        context.referenceY = utils.getPoint(e, context.hasTouch).y;\n\t\n\t        context.velocityTop = context.amplitudeTop = 0;\n\t        context.velocityLeft = context.amplitudeLeft = 0;\n\t\n\t        context.lastScrollTop = context.scrollTop;\n\t        context.lastScrollLeft = context.scrollLeft;\n\t\n\t        context.timeStamp = utils.getTime();\n\t\n\t        context.cancelAutoScroll();\n\t\n\t        context.$listener.addEventListener('mousemove', context.swipe, true);\n\t        context.$listener.addEventListener('mouseup', context.release, true);\n\t\n\t        if (utils.preventDefaultException(e.target, context.userOptions.preventDefaultException)) {\n\t            e.preventDefault();\n\t        }\n\t    };\n\t\n\t    context.swipe = function (e) {\n\t        var x, y, deltaX, deltaY;\n\t\n\t        if (context.pressed) {\n\t            x = utils.getPoint(e, context.hasTouch).x;\n\t            y = utils.getPoint(e, context.hasTouch).y;\n\t\n\t            deltaX = context.referenceX - x;\n\t            deltaY = context.referenceY - y;\n\t\n\t            if (deltaX > 2 || deltaX < -2) {\n\t                context.referenceX = x;\n\t            } else {\n\t                deltaX = 0;\n\t            }\n\t            if (deltaY > 2 || deltaY < -2) {\n\t                context.referenceY = y;\n\t            } else {\n\t                deltaY = 0;\n\t            }\n\t\n\t            context.topTracker();\n\t            context.leftTracker();\n\t\n\t            context.scroll(context.scrollLeft + deltaX, context.scrollTop + deltaY);\n\t        }\n\t    };\n\t\n\t    context.release = function () {\n\t        var targetLeft, targetTop, amplitudeLeft, amplitudeTop;\n\t\n\t        context.pressed = false;\n\t\n\t        context.topTracker();\n\t        context.leftTracker();\n\t\n\t        if (context.velocityLeft > 10 || context.velocityLeft < -10) {\n\t            amplitudeLeft = 0.8 * context.velocityLeft;\n\t            targetLeft = Math.round(context.scrollLeft + amplitudeLeft);\n\t        } else {\n\t            targetLeft = context.scrollLeft;\n\t        }\n\t        if (context.velocityTop > 10 || context.velocityTop < -10) {\n\t            amplitudeTop = 0.8 * context.velocityTop;\n\t            targetTop = Math.round(context.scrollTop + amplitudeTop);\n\t        } else {\n\t            targetTop = context.scrollTop;\n\t        }\n\t\n\t        context.triggerAutoScroll(targetLeft, targetTop, amplitudeLeft, amplitudeTop);\n\t\n\t        context.$listener.removeEventListener('mousemove', context.swipe);\n\t        context.$listener.removeEventListener('mouseup', context.release);\n\t    };\n\t\n\t    if (!context.hasTouch && context.userOptions.enableKinetics) {\n\t        context.$listener.addEventListener('mousedown', context.tap, true);\n\t    }\n\t\n\t    context.$on('$destroy', function () {\n\t        context.$listener.removeEventListener('mousedown', context.tap);\n\t    });\n\t\n\t    var scrollGen = function (start, left, top) {\n\t        return function () {\n\t            var targetLeft = 0,\n\t                targetTop = 0,\n\t                amplitudeLeft = 0,\n\t                amplitudeTop = 0,\n\t                maxScroll = {};\n\t\n\t            if (start) {\n\t                targetLeft = left ? 0 : context.scrollLeft;\n\t                targetTop = top ? 0 : context.scrollTop;\n\t                amplitudeLeft = left ? -context.scrollLeft : 0;\n\t                amplitudeTop = top ? -context.scrollTop : 0;\n\t            } else {\n\t                maxScroll = utils.getMaxScroll(context.childNodes);\n\t\n\t                targetLeft = left ? maxScroll.left : context.scrollLeft;\n\t                targetTop = top ? maxScroll.top : context.scrollTop;\n\t                amplitudeLeft = left ? maxScroll.left - context.scrollLeft : 0;\n\t                amplitudeTop = top ? maxScroll.top - context.scrollTop : 0;\n\t            }\n\t\n\t            context.triggerAutoScroll(targetLeft, targetTop, amplitudeLeft, amplitudeTop);\n\t        };\n\t    };\n\t\n\t    var scrollToBy = function (addTo) {\n\t        return function (left, top) {\n\t            var maxScroll, numLeft, corrLeft, numTop, corrTop, targetLeft, targetTop, moveLeft, moveTop, amplitudeLeft, amplitudeTop;\n\t\n\t            maxScroll = utils.getMaxScroll(context.childNodes);\n\t\n\t            numLeft = parseInt(left);\n\t            numTop = parseInt(top);\n\t\n\t            corrLeft = isNaN(numLeft) ? context.scrollLeft : addTo ? numLeft + context.scrollLeft : numLeft;\n\t            corrTop = isNaN(numTop) ? context.scrollTop : addTo ? numTop + context.scrollTop : numTop;\n\t\n\t            targetLeft = corrLeft > maxScroll.left ? maxScroll.left : corrLeft < 0 ? 0 : corrLeft;\n\t            targetTop = corrTop > maxScroll.top ? maxScroll.top : corrTop < 0 ? 0 : corrTop;\n\t\n\t            moveLeft = context.scrollLeft - targetLeft !== 0 ? true : false;\n\t            moveTop = context.scrollTop - targetTop !== 0 ? true : false;\n\t\n\t            amplitudeLeft = moveLeft ? targetLeft - context.scrollLeft : 0;\n\t            amplitudeTop = moveTop ? targetTop - context.scrollTop : 0;\n\t\n\t            context.triggerAutoScroll(targetLeft, targetTop, amplitudeLeft, amplitudeTop);\n\t        };\n\t    };\n\t\n\t    var start = true,\n\t        notStart = false,\n\t        left = true,\n\t        notLeft = false,\n\t        top = true,\n\t        notTop = false,\n\t        toValue = false,\n\t        byValue = true;\n\t\n\t    context.exposedMethods = {\n\t        scrollToStart: scrollGen(start, left, top),\n\t        scrollToStartLeft: scrollGen(start, left, notTop),\n\t        scrollToStartTop: scrollGen(start, notLeft, top),\n\t        scrollToEnd: scrollGen(notStart, left, top),\n\t        scrollToEndLeft: scrollGen(notStart, left, notTop),\n\t        scrollToEndTop: scrollGen(notStart, notLeft, top),\n\t        scrollToPosition: scrollToBy(toValue),\n\t        scrollByValue: scrollToBy(byValue)\n\t    };\n\t}\n\t\n\tmodule.exports = KineticEngine;\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tfunction ConnectScrolls(augNsUtils, augNsOptions, kineticEngine) {\n\t    return {\n\t        restrict: 'E',\n\t        scope: {\n\t            options: '='\n\t        },\n\t        transclude: true,\n\t        replace: true,\n\t        template: '<span data-name=\"conntect-scroll\" ng-transclude></span>',\n\t        link: function (scope, element) {\n\t            scope.hasTouch = 'ontouchstart' in window;\n\t            scope.DETECT_EVT = scope.hasTouch ? 'touchstart' : 'mouseover';\n\t            scope.activeId = undefined;\n\t            scope.$listener = element[0];\n\t\n\t            scope.userOptions = angular.extend({}, augNsOptions, scope.options);\n\t\n\t            kineticEngine.call(this, scope, augNsUtils);\n\t\n\t            scope.setActiveNode = function (e) {\n\t                scope.activeId = augNsUtils.findMatchingTarget(e.target, scope.childNodes);\n\t            };\n\t\n\t            scope.onScroll = function (e) {\n\t                if (scope.pressed || scope.isAutoScrolling) {\n\t                    e.preventDefault();\n\t                    e.stopPropagation();\n\t                    return;\n\t                }\n\t\n\t                var target = e.target;\n\t                var valX = undefined;\n\t                var valY = undefined;\n\t\n\t                if (target.clientWidth !== target.scrollWidth) {\n\t                    valX = target.scrollLeft;\n\t                    scope.lastScrollLeft = scope.scrollLeft;\n\t                    scope.scrollLeft = valX;\n\t                } else {\n\t                    valX = scope.scrollLeft;\n\t                }\n\t                if (target.clientHeight !== target.scrollHeight) {\n\t                    valY = target.scrollTop;\n\t                    scope.lastScrollTop = scope.scrollTop;\n\t                    scope.scrollTop = valY;\n\t                } else {\n\t                    valY = scope.scrollTop;\n\t                }\n\t\n\t                scope.childNodes.forEach(function (node) {\n\t                    if (node.id !== scope.activeId) {\n\t                        node.children[0].scrollLeft = valX;\n\t                        node.children[0].scrollTop = valY;\n\t                    }\n\t                });\n\t            };\n\t\n\t            scope.$listener.addEventListener(scope.DETECT_EVT, scope.setActiveNode, true);\n\t            scope.$listener.addEventListener('scroll', scope.onScroll, true);\n\t\n\t            scope.$on('$destroy', function () {\n\t                scope.$listener.removeEventListener(scope.DETECT_EVT, scope.setActiveNode);\n\t                scope.$listener.removeEventListener('scroll', scope.onScroll);\n\t            });\n\t\n\t            // expose few methods to the parent controller\n\t            scope.$parent.augNs = scope.exposedMethods;\n\t        },\n\t        controller: ['$scope', function connectScrollsCtrl($scope) {\n\t            var childNodes = $scope.childNodes = [];\n\t\n\t            this.addScrollArea = function (node) {\n\t                childNodes.push(node);\n\t            };\n\t        }]\n\t    };\n\t}\n\t\n\tConnectScrolls.$inject = ['augNsUtils', 'augNsOptions', 'kineticEngine'];\n\t\n\tmodule.exports = ConnectScrolls;\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tfunction ScrollArea() {\n\t    return {\n\t        require: '^^connectScrolls',\n\t        restrict: 'E',\n\t        transclude: true,\n\t        replace: true,\n\t        template: '<span  data-name=\"scroll-area\" ng-transclude></span>',\n\t        link: function (scope, element, attrs, connectScrollsCtrl) {\n\t            element.attr('id', 'PARTICIPATING_NODE_' + Math.random().toString().substring(2, 15));\n\t            connectScrollsCtrl.addScrollArea(element[0]);\n\t        }\n\t    };\n\t}\n\t\n\tmodule.exports = ScrollArea;\n\n/***/ },\n/* 7 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tfunction KineticScroll(augNsUtils, augNsOptions, kineticEngine) {\n\t    return {\n\t        restrict: 'E',\n\t        scope: {\n\t            options: '='\n\t        },\n\t        transclude: true,\n\t        replace: true,\n\t        template: '<span data-name=\"kinetic-scroll\" ng-transclude></span>',\n\t        link: function (scope, element) {\n\t            scope.hasTouch = 'ontouchstart' in window;\n\t            scope.DETECT_EVT = scope.hasTouch ? 'touchstart' : 'mouseover';\n\t            scope.$listener = element[0];\n\t            scope.childNodes = [scope.$listener];\n\t\n\t            scope.userOptions = angular.extend({}, augNsOptions, scope.options);\n\t\n\t            kineticEngine.call(this, scope, augNsUtils);\n\t\n\t            // expose few methods to the parent controller\n\t            scope.$parent.augNs = scope.exposedMethods;\n\t        }\n\t    };\n\t}\n\t\n\tKineticScroll.$inject = ['augNsUtils', 'augNsOptions', 'kineticEngine'];\n\t\n\tmodule.exports = KineticScroll;\n\n/***/ }\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// ./dist/ngAugmentNativeScroll.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 541487ee3ec4b219c758","'use strict';\r\n\r\nvar angular = require('angular');\r\n\r\nangular.module('ngAugmentNativeScroll', [])\r\n    .factory('augNsUtils', require('./augNsUtils.factory.js'))\r\n    .value('augNsOptions', require('./augNsOptions.value.js'))\r\n    .value('kineticEngine', require('./kineticEngine.value.js'))\r\n    .directive('connectScrolls', require('./connectScrolls.directive.js'))\r\n    .directive('scrollArea', require('./scrollArea.directive.js'))\r\n    .directive('kineticScroll', require('./kineticScroll.directive.js'));\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","module.exports = angular;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"angular\"\n// module id = 1\n// module chunks = 0","function augNsUtils () {\r\n     /*eslint-disable angular/window-service, angular/timeout-service */\r\n    (function() {\r\n        var lastTime = 0;\r\n        var vendors = ['ms', 'moz', 'webkit', 'o'];\r\n        for(var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {\r\n            window.requestAnimationFrame = window[vendors[x]+'RequestAnimationFrame'];\r\n            window.cancelAnimationFrame = window[vendors[x]+'CancelAnimationFrame'] || window[vendors[x]+'CancelRequestAnimationFrame'];\r\n        }\r\n\r\n        if ( ! window.requestAnimationFrame ) {\r\n            window.requestAnimationFrame = function(callback) {\r\n                var currTime = new Date().getTime();\r\n                var timeToCall = Math.max(0, 16 - (currTime - lastTime));\r\n                var id = window.setTimeout(function() {\r\n                    callback(currTime + timeToCall);\r\n                }, timeToCall);\r\n                lastTime = currTime + timeToCall;\r\n                return id;\r\n            };\r\n        }\r\n\r\n        if ( ! window.cancelAnimationFrame ) {\r\n            window.cancelAnimationFrame = function(id) {\r\n                clearTimeout(id);\r\n            }\r\n        }\r\n    }());\r\n\r\n    return {\r\n        findMatchingTarget: function (target, nodes) {\r\n            var found;\r\n\r\n            if ( ! nodes.length || target.tagName === 'BODY' ) {\r\n                return 'BODY';\r\n            }\r\n\r\n            found = nodes.find(function (node) {\r\n                return node.id === target.id\r\n            });\r\n\r\n            if ( found ) {\r\n                return target.id;\r\n            } else {\r\n                return this.findMatchingTarget(target.parentElement, nodes);\r\n            }\r\n        },\r\n        getPoint: function (e, hasTouch) {\r\n            var point;\r\n\r\n            if( hasTouch && event.touches.length ) {\r\n                point = {\r\n                    x : event.touches[0].clientX,\r\n                    y : event.touches[0].clientY\r\n                }\r\n            } else {\r\n                point = {\r\n                    x : event.clientX,\r\n                    y : event.clientY\r\n                }\r\n            }\r\n\r\n            return point;\r\n        },\r\n        getTime: Date.now || function getTime () {\r\n            return new Date().utils.getTime();\r\n        },\r\n        preventDefaultException: function (el, exceptions) {\r\n            for ( var i in exceptions ) {\r\n                if ( exceptions[i].test(el[i]) ) {\r\n                    return true;\r\n                }\r\n            }\r\n\r\n            return false;\r\n        },\r\n        getMaxScroll: function (nodes) {\r\n            var maxScrollLeft = 0,\r\n                maxScrollTop = 0;\r\n\r\n            nodes.forEach(function (node) {\r\n                var $el = node.children[0];\r\n                var maxScrollX = $el.scrollWidth - $el.clientWidth;\r\n                var maxScrollY = $el.scrollHeight - $el.clientHeight;\r\n\r\n                if ( maxScrollX > maxScrollLeft ) {\r\n                    maxScrollLeft = maxScrollX;\r\n                }\r\n                if ( maxScrollY > maxScrollTop ) {\r\n                    maxScrollTop = maxScrollY;\r\n                }\r\n            });\r\n\r\n            return {\r\n                left: maxScrollLeft,\r\n                top: maxScrollTop\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nmodule.exports = augNsUtils;\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/augNsUtils.factory.js","'use strict';\r\n\r\nvar augNsOptions = {\r\n    enableKinetics: true,\r\n    movingAverage: 0.1,\r\n    preventDefaultException: {\r\n        tagName: /^(INPUT|TEXTAREA|BUTTON|SELECT)$/\r\n    }\r\n}\r\n\r\nmodule.exports = augNsOptions;\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/augNsOptions.value.js","'use strict';\r\n\r\nfunction KineticEngine (context, utils) {\r\n    context.scrollLeft = 0;\r\n    context.scrollTop = 0;\r\n    context.lastScrollLeft = 0;\r\n    context.lastScrollTop = 0;\r\n    context.targetTop = 0;\r\n    context.targetLeft = 0;\r\n\r\n    context.velocityTop = 0;\r\n    context.velocityLeft = 0;\r\n    context.amplitudeTop = 0;\r\n    context.amplitudeLeft = 0;\r\n\r\n    context.timeStamp = 0;\r\n    context.referenceX = 0;\r\n    context.referenceY = 0;\r\n    context.pressed = false;\r\n    context.autoScrollTracker = null;\r\n    context.isAutoScrolling = false;\r\n\r\n    context.leftTracker = function () {\r\n        var now, elapsed, delta;\r\n\r\n        now = utils.getTime();\r\n        elapsed = now - context.timeStamp;\r\n        context.timeStamp = now;\r\n        delta = context.scrollLeft - context.lastScrollLeft;\r\n        context.lastScrollLeft = context.scrollLeft;\r\n\r\n        context.velocityLeft = context.userOptions.movingAverage * (1000 * delta / (1 + elapsed)) + 0.2 * context.velocityLeft;\r\n    }\r\n\r\n    context.topTracker = function () {\r\n        var now, elapsed, delta;\r\n\r\n        now = utils.getTime();\r\n        elapsed = now - context.timeStamp;\r\n        context.timeStamp = now;\r\n        delta = context.scrollTop - context.lastScrollTop;\r\n        context.lastScrollTop = context.scrollTop;\r\n\r\n        context.velocityTop = context.userOptions.movingAverage * (1000 * delta / (1 + elapsed)) + 0.2 * context.velocityTop;\r\n    }\r\n\r\n    context.scroll = function(left, top) {\r\n        var correctedLeft = Math.round(left);\r\n        var correctedTop = Math.round(top);\r\n\r\n        context.childNodes.forEach(function(node) {\r\n            var $el = node.children[0];\r\n            var maxScrollX = $el.scrollWidth - $el.clientWidth;\r\n            var maxScrollY = $el.scrollHeight - $el.clientHeight;\r\n\r\n            if ( maxScrollX > 0 && correctedLeft >= 0 && correctedLeft <= maxScrollX ) {\r\n                $el.scrollLeft = correctedLeft;\r\n                context.scrollLeft = correctedLeft;\r\n            }\r\n            if ( maxScrollY > 0 && correctedTop >= 0 && correctedTop <= maxScrollY ) {\r\n                $el.scrollTop = correctedTop;\r\n                context.scrollTop = correctedTop;\r\n            }\r\n        })\r\n    }\r\n\r\n    context.autoScroll = function() {\r\n        var elapsed;\r\n        var deltaY = 0, deltaX = 0, scrollX = 0, scrollY = 0;\r\n        var timeConstant = 325;\r\n\r\n        elapsed = utils.getTime() - context.timeStamp;\r\n\r\n        if ( context.amplitudeTop ) {\r\n            deltaY = -context.amplitudeTop * Math.exp(-elapsed / timeConstant);\r\n        }\r\n        if ( context.amplitudeLeft ) {\r\n            deltaX = -context.amplitudeLeft * Math.exp(-elapsed / timeConstant);\r\n        }\r\n\r\n        if ( deltaX > 0.5 || deltaX < -0.5 ) {\r\n            scrollX = deltaX;\r\n        } else {\r\n            scrollX = 0;\r\n        }\r\n\r\n        if ( deltaY > 0.5 || deltaY < -0.5 ) {\r\n            scrollY = deltaY;\r\n        } else {\r\n            scrollY = 0;\r\n        }\r\n\r\n        context.scroll(context.targetLeft + scrollX, context.targetTop + scrollY);\r\n\r\n        if ( scrollX !== 0 || scrollY !== 0 ) {\r\n            context.autoScrollTracker = requestAnimationFrame(context.autoScroll);\r\n        } else {\r\n            context.isAutoScrolling = false;\r\n            context.autoScrollTracker = null;\r\n        }\r\n    }\r\n\r\n    context.triggerAutoScroll = function (targetLeft, targetTop, amplitudeLeft, amplitudeTop) {\r\n        if ( amplitudeLeft !== 0 || amplitudeTop !== 0 ) {\r\n            context.cancelAutoScroll();\r\n\r\n            context.timeStamp = utils.getTime();\r\n            context.targetLeft = targetLeft;\r\n            context.targetTop = targetTop;\r\n            context.amplitudeLeft = amplitudeLeft;\r\n            context.amplitudeTop = amplitudeTop;\r\n\r\n            context.isAutoScrolling = true;\r\n            context.autoScrollTracker = requestAnimationFrame(context.autoScroll);\r\n        }\r\n    }\r\n\r\n    context.cancelAutoScroll = function () {\r\n        if ( context.isAutoScrolling ) {\r\n            cancelAnimationFrame(context.autoScrollTracker);\r\n            context.isAutoScrolling = false;\r\n            context.autoScrollTracker = null;\r\n        }\r\n    }\r\n\r\n    context.tap = function (e) {\r\n        context.pressed = true;\r\n        context.referenceX = utils.getPoint(e, context.hasTouch).x;\r\n        context.referenceY = utils.getPoint(e, context.hasTouch).y;\r\n\r\n        context.velocityTop = context.amplitudeTop = 0;\r\n        context.velocityLeft = context.amplitudeLeft = 0;\r\n\r\n        context.lastScrollTop = context.scrollTop;\r\n        context.lastScrollLeft = context.scrollLeft;\r\n\r\n        context.timeStamp = utils.getTime();\r\n\r\n        context.cancelAutoScroll();\r\n\r\n        context.$listener.addEventListener( 'mousemove', context.swipe, true );\r\n        context.$listener.addEventListener( 'mouseup', context.release, true );\r\n\r\n        if ( utils.preventDefaultException(e.target, context.userOptions.preventDefaultException) ) {\r\n            e.preventDefault();\r\n        }\r\n    }\r\n\r\n    context.swipe = function (e) {\r\n        var x, y, deltaX, deltaY;\r\n\r\n        if (context.pressed) {\r\n            x = utils.getPoint(e, context.hasTouch).x;\r\n            y = utils.getPoint(e, context.hasTouch).y;\r\n\r\n            deltaX = context.referenceX - x;\r\n            deltaY = context.referenceY - y;\r\n\r\n            if (deltaX > 2 || deltaX < -2) {\r\n                context.referenceX = x;\r\n            } else {\r\n                deltaX = 0;\r\n            }\r\n            if (deltaY > 2 || deltaY < -2) {\r\n                context.referenceY = y;\r\n            } else {\r\n                deltaY = 0;\r\n            }\r\n\r\n            context.topTracker();\r\n            context.leftTracker();\r\n\r\n            context.scroll( context.scrollLeft + deltaX, context.scrollTop + deltaY );\r\n        }\r\n    }\r\n\r\n    context.release = function() {\r\n        var targetLeft, targetTop, amplitudeLeft, amplitudeTop;\r\n\r\n        context.pressed = false;\r\n\r\n        context.topTracker();\r\n        context.leftTracker();\r\n\r\n        if (context.velocityLeft > 10 || context.velocityLeft < -10) {\r\n            amplitudeLeft = 0.8 * context.velocityLeft;\r\n            targetLeft = Math.round(context.scrollLeft + amplitudeLeft);\r\n        } else {\r\n            targetLeft = context.scrollLeft;\r\n        }\r\n        if (context.velocityTop > 10 || context.velocityTop < -10) {\r\n            amplitudeTop = 0.8 * context.velocityTop;\r\n            targetTop = Math.round(context.scrollTop + amplitudeTop);\r\n        } else {\r\n            targetTop = context.scrollTop;\r\n        }\r\n\r\n        context.triggerAutoScroll(targetLeft, targetTop, amplitudeLeft, amplitudeTop);\r\n\r\n        context.$listener.removeEventListener( 'mousemove', context.swipe );\r\n        context.$listener.removeEventListener( 'mouseup', context.release );\r\n    }\r\n\r\n    if ( ! context.hasTouch && context.userOptions.enableKinetics ) {\r\n        context.$listener.addEventListener( 'mousedown', context.tap, true );\r\n    }\r\n\r\n    context.$on('$destroy', function() {\r\n        context.$listener.removeEventListener( 'mousedown', context.tap );\r\n    });\r\n\r\n    var scrollGen = function (start, left, top) {\r\n        return function () {\r\n            var targetLeft = 0,\r\n                targetTop = 0,\r\n                amplitudeLeft = 0,\r\n                amplitudeTop = 0,\r\n                maxScroll = {};\r\n\r\n            if ( start ) {\r\n                targetLeft = left ? 0 : context.scrollLeft;\r\n                targetTop = top ? 0 : context.scrollTop;\r\n                amplitudeLeft = left ? -context.scrollLeft : 0;\r\n                amplitudeTop = top ? -context.scrollTop : 0;\r\n            } else {\r\n                maxScroll = utils.getMaxScroll(context.childNodes);\r\n\r\n                targetLeft = left ? maxScroll.left : context.scrollLeft;\r\n                targetTop = top ? maxScroll.top : context.scrollTop;\r\n                amplitudeLeft = left ? maxScroll.left - context.scrollLeft : 0;\r\n                amplitudeTop = top ? maxScroll.top - context.scrollTop : 0;\r\n            }\r\n\r\n            context.triggerAutoScroll(targetLeft, targetTop, amplitudeLeft, amplitudeTop);\r\n        }\r\n    }\r\n\r\n    var scrollToBy = function (addTo) {\r\n        return function (left, top) {\r\n            var maxScroll, numLeft, corrLeft, numTop, corrTop, targetLeft, targetTop, moveLeft, moveTop, amplitudeLeft, amplitudeTop;\r\n\r\n            maxScroll = utils.getMaxScroll(context.childNodes);\r\n\r\n            numLeft = parseInt(left);\r\n            numTop = parseInt(top);\r\n\r\n            corrLeft = isNaN( numLeft ) ? context.scrollLeft : (addTo ? numLeft + context.scrollLeft : numLeft);\r\n            corrTop = isNaN( numTop ) ? context.scrollTop : (addTo ? numTop + context.scrollTop : numTop);\r\n\r\n            targetLeft = corrLeft > maxScroll.left ? maxScroll.left : (corrLeft < 0 ? 0 : corrLeft);\r\n            targetTop = corrTop > maxScroll.top ? maxScroll.top : (corrTop < 0 ? 0 : corrTop);\r\n\r\n            moveLeft = context.scrollLeft - targetLeft !== 0 ? true : false;\r\n            moveTop = context.scrollTop - targetTop !== 0 ? true : false;\r\n\r\n            amplitudeLeft = moveLeft ? targetLeft - context.scrollLeft : 0;\r\n            amplitudeTop = moveTop ? targetTop - context.scrollTop : 0;\r\n\r\n            context.triggerAutoScroll(targetLeft, targetTop, amplitudeLeft, amplitudeTop);\r\n        }\r\n    }\r\n\r\n    var start = true,\r\n        notStart = false,\r\n        left = true,\r\n        notLeft = false,\r\n        top = true,\r\n        notTop = false,\r\n        toValue = false,\r\n        byValue = true;\r\n\r\n    context.exposedMethods = {\r\n        scrollToStart: scrollGen(start, left, top),\r\n        scrollToStartLeft: scrollGen(start, left, notTop),\r\n        scrollToStartTop: scrollGen(start, notLeft, top),\r\n        scrollToEnd: scrollGen(notStart, left, top),\r\n        scrollToEndLeft: scrollGen(notStart, left, notTop),\r\n        scrollToEndTop: scrollGen(notStart, notLeft, top),\r\n        scrollToPosition: scrollToBy(toValue),\r\n        scrollByValue: scrollToBy(byValue)\r\n    }\r\n}\r\n\r\nmodule.exports = KineticEngine;\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/kineticEngine.value.js","'use strict';\r\n\r\nfunction ConnectScrolls (augNsUtils, augNsOptions, kineticEngine) {\r\n    return {\r\n        restrict: 'E',\r\n        scope: {\r\n            options: '='\r\n        },\r\n        transclude: true,\r\n        replace: true,\r\n        template: '<span data-name=\"conntect-scroll\" ng-transclude></span>',\r\n        link: function (scope, element) {\r\n            scope.hasTouch = 'ontouchstart' in window;\r\n            scope.DETECT_EVT = scope.hasTouch ? 'touchstart' : 'mouseover';\r\n            scope.activeId = undefined;\r\n            scope.$listener = element[0];\r\n\r\n            scope.userOptions = angular.extend({}, augNsOptions, scope.options);\r\n\r\n            kineticEngine.call(this, scope, augNsUtils);\r\n\r\n            scope.setActiveNode = function (e) {\r\n                scope.activeId = augNsUtils.findMatchingTarget(e.target, scope.childNodes);\r\n            }\r\n\r\n            scope.onScroll = function (e) {\r\n                if ( scope.pressed || scope.isAutoScrolling ) {\r\n                    e.preventDefault();\r\n                    e.stopPropagation();\r\n                    return;\r\n                }\r\n\r\n                var target = e.target;\r\n                var valX = undefined;\r\n                var valY = undefined;\r\n\r\n                if ( target.clientWidth !== target.scrollWidth ) {\r\n                    valX = target.scrollLeft;\r\n                    scope.lastScrollLeft = scope.scrollLeft;\r\n                    scope.scrollLeft = valX;\r\n                } else {\r\n                    valX = scope.scrollLeft;\r\n                }\r\n                if ( target.clientHeight !== target.scrollHeight ) {\r\n                    valY = target.scrollTop;\r\n                    scope.lastScrollTop = scope.scrollTop;\r\n                    scope.scrollTop = valY;\r\n                } else {\r\n                    valY = scope.scrollTop;\r\n                }\r\n\r\n                scope.childNodes.forEach(function(node) {\r\n                    if ( node.id !== scope.activeId ) {\r\n                        node.children[0].scrollLeft = valX;\r\n                        node.children[0].scrollTop = valY;\r\n                    }\r\n                });\r\n            }\r\n\r\n            scope.$listener.addEventListener( scope.DETECT_EVT, scope.setActiveNode, true );\r\n            scope.$listener.addEventListener( 'scroll', scope.onScroll, true );\r\n\r\n            scope.$on('$destroy', function() {\r\n                scope.$listener.removeEventListener( scope.DETECT_EVT, scope.setActiveNode );\r\n                scope.$listener.removeEventListener( 'scroll', scope.onScroll );\r\n            });\r\n\r\n            // expose few methods to the parent controller\r\n            scope.$parent.augNs = scope.exposedMethods;\r\n        },\r\n        controller: ['$scope', function connectScrollsCtrl($scope) {\r\n            var childNodes = $scope.childNodes = [];\r\n\r\n            this.addScrollArea = function (node) {\r\n                childNodes.push(node);\r\n            }\r\n        }]\r\n    }\r\n}\r\n\r\nConnectScrolls.$inject = ['augNsUtils', 'augNsOptions', 'kineticEngine'];\r\n\r\nmodule.exports = ConnectScrolls;\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/connectScrolls.directive.js","'use strict';\r\n\r\nfunction ScrollArea () {\r\n    return {\r\n        require: '^^connectScrolls',\r\n        restrict: 'E',\r\n        transclude: true,\r\n        replace: true,\r\n        template: '<span  data-name=\"scroll-area\" ng-transclude></span>',\r\n        link: function (scope, element, attrs, connectScrollsCtrl) {\r\n            element.attr( 'id', 'PARTICIPATING_NODE_' + Math.random().toString().substring(2, 15) );\r\n            connectScrollsCtrl.addScrollArea(element[0]);\r\n        }\r\n    }\r\n}\r\n\r\nmodule.exports = ScrollArea;\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/scrollArea.directive.js","'use strict';\r\n\r\nfunction KineticScroll (augNsUtils, augNsOptions, kineticEngine) {\r\n    return {\r\n        restrict: 'E',\r\n        scope: {\r\n            options: '='\r\n        },\r\n        transclude: true,\r\n        replace: true,\r\n        template: '<span data-name=\"kinetic-scroll\" ng-transclude></span>',\r\n        link: function (scope, element) {\r\n            scope.hasTouch = 'ontouchstart' in window;\r\n            scope.DETECT_EVT = scope.hasTouch ? 'touchstart' : 'mouseover';\r\n            scope.$listener = element[0];\r\n            scope.childNodes = [ scope.$listener ];\r\n\r\n            scope.userOptions = angular.extend({}, augNsOptions, scope.options);\r\n\r\n            kineticEngine.call(this, scope, augNsUtils);\r\n\r\n            // expose few methods to the parent controller\r\n            scope.$parent.augNs = scope.exposedMethods;\r\n        }\r\n    }\r\n}\r\n\r\nKineticScroll.$inject = ['augNsUtils', 'augNsOptions', 'kineticEngine'];\r\n\r\nmodule.exports = KineticScroll;\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/kineticScroll.directive.js"],"sourceRoot":""}