{"version":3,"sources":["webpack:///ngAugmentNativeScroll.min.js","webpack:///webpack/bootstrap e7fe1802638f78092050","webpack:///./index.js","webpack:///./kineticEngine.value.js","webpack:///./utils.factory.js","webpack:///./connectScrolls.directive.js","webpack:///./scrollArea.directive.js","webpack:///./kineticScroll.directive.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","angular","value","factory","directive","KineticEngine","context","utils","scrollLeft","scrollTop","lastScrollLeft","lastScrollTop","targetTop","targetLeft","velocityTop","velocityLeft","amplitudeTop","amplitudeLeft","timeStamp","referenceX","referenceY","pressed","autoScrollTracker","isAutoScrolling","leftTracker","now","elapsed","delta","getTime","userOptions","movingAverage","topTracker","scrollTo","left","top","correctedLeft","Math","round","correctedTop","childNodes","forEach","node","$el","children","maxScrollX","scrollWidth","clientWidth","maxScrollY","scrollHeight","clientHeight","autoScroll","deltaY","deltaX","scrollX","scrollY","timeConstant","exp","requestAnimationFrame","cancelAutoScroll","cancelAnimationFrame","tap","e","getPoint","hasTouch","x","y","$listener","addEventListener","swipe","end","preventDefault","stopPropagation","removeEventListener","enableKinetics","$on","UtilsFactory","findMatchingTarget","target","nodes","found","length","tagName","find","this","parentElement","point","event","touches","clientX","clientY","Date","ConnectScrolls","kineticEngine","restrict","scope","options","transclude","replace","template","link","element","window","DETECT_EVT","activeId","undefined","defaultOptions","extend","setActiveNode","onScroll","valX","valY","$parent","connectedScrolls","scrollToStart","scrollToStartLeft","scrollToStartTop","scrollToEnd","maxScrollLeft","maxScrollTop","scrollToEndLeft","scrollToEndTop","controller","$scope","addScrollArea","push","$inject","ScrollArea","require","attrs","connectScrollsCtrl","attr","random","toString","substring","KineticScroll","kineticScroll"],"mappings":"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","file":"ngAugmentNativeScroll.min.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\r\n\t\r\n\tangular.module('ngAugmentNativeScroll', [])\r\n\t    .value('kineticEngine', __webpack_require__(1))\r\n\t    .factory('utils', __webpack_require__(2))\r\n\t    .directive('connectScrolls', __webpack_require__(3))\r\n\t    .directive('scrollArea', __webpack_require__(4))\r\n\t    .directive('kineticScroll', __webpack_require__(5));\r\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t'use strict';\r\n\t\r\n\tfunction KineticEngine (context, utils) {\r\n\t    context.scrollLeft = 0;\r\n\t    context.scrollTop = 0;\r\n\t    context.lastScrollLeft = 0;\r\n\t    context.lastScrollTop = 0;\r\n\t    context.targetTop = 0;\r\n\t    context.targetLeft = 0;\r\n\t\r\n\t    context.velocityTop = 0;\r\n\t    context.velocityLeft = 0;\r\n\t    context.amplitudeTop = 0;\r\n\t    context.amplitudeLeft = 0;\r\n\t\r\n\t    context.timeStamp = 0;\r\n\t    context.referenceX = 0;\r\n\t    context.referenceY = 0;\r\n\t    context.pressed = false;\r\n\t    context.autoScrollTracker = null;\r\n\t    context.isAutoScrolling = false;\r\n\t\r\n\t    context.leftTracker = function () {\r\n\t        var now, elapsed, delta;\r\n\t\r\n\t        now = utils.getTime();\r\n\t        elapsed = now - context.timeStamp;\r\n\t        context.timeStamp = now;\r\n\t        delta = context.scrollLeft - context.lastScrollLeft;\r\n\t        context.lastScrollLeft = context.scrollLeft;\r\n\t\r\n\t        context.velocityLeft = context.userOptions.movingAverage * (1000 * delta / (1 + elapsed)) + 0.2 * context.velocityLeft;\r\n\t    }\r\n\t\r\n\t    context.topTracker = function () {\r\n\t        var now, elapsed, delta;\r\n\t\r\n\t        now = utils.getTime();\r\n\t        elapsed = now - context.timeStamp;\r\n\t        context.timeStamp = now;\r\n\t        delta = context.scrollTop - context.lastScrollTop;\r\n\t        context.lastScrollTop = context.scrollTop;\r\n\t\r\n\t        context.velocityTop = context.userOptions.movingAverage * (1000 * delta / (1 + elapsed)) + 0.2 * context.velocityTop;\r\n\t    }\r\n\t\r\n\t    context.scrollTo = function(left, top) {\r\n\t        var correctedLeft = Math.round(left);\r\n\t        var correctedTop = Math.round(top);\r\n\t\r\n\t        context.childNodes.forEach(function(node) {\r\n\t            var $el = node.children[0];\r\n\t            var maxScrollX = $el.scrollWidth - $el.clientWidth;\r\n\t            var maxScrollY = $el.scrollHeight - $el.clientHeight;\r\n\t\r\n\t            if ( maxScrollX > 0 && correctedLeft >= 0 && correctedLeft <= maxScrollX ) {\r\n\t                $el.scrollLeft = correctedLeft;\r\n\t                context.scrollLeft = correctedLeft;\r\n\t            }\r\n\t            if ( maxScrollY > 0 && correctedTop >= 0 && correctedTop <= maxScrollY ) {\r\n\t                $el.scrollTop = correctedTop;\r\n\t                context.scrollTop = correctedTop;\r\n\t            }\r\n\t        })\r\n\t    }\r\n\t\r\n\t    context.autoScroll = function() {\r\n\t        var elapsed;\r\n\t        var deltaY = 0, deltaX = 0, scrollX = 0, scrollY = 0;\r\n\t        var timeConstant = 325;\r\n\t\r\n\t        elapsed = utils.getTime() - context.timeStamp;\r\n\t\r\n\t        if ( context.amplitudeTop ) {\r\n\t            deltaY = -context.amplitudeTop * Math.exp(-elapsed / timeConstant);\r\n\t        }\r\n\t        if ( context.amplitudeLeft ) {\r\n\t            deltaX = -context.amplitudeLeft * Math.exp(-elapsed / timeConstant);\r\n\t        }\r\n\t\r\n\t        if ( deltaX > 0.5 || deltaX < -0.5 ) {\r\n\t            scrollX = deltaX;\r\n\t        } else {\r\n\t            scrollX = 0;\r\n\t        }\r\n\t\r\n\t        if ( deltaY > 0.5 || deltaY < -0.5 ) {\r\n\t            scrollY = deltaY;\r\n\t        } else {\r\n\t            scrollY = 0;\r\n\t        }\r\n\t\r\n\t        context.scrollTo(context.targetLeft + scrollX, context.targetTop + scrollY);\r\n\t\r\n\t        if ( scrollX !== 0 || scrollY !== 0 ) {\r\n\t            context.autoScrollTracker = requestAnimationFrame(context.autoScroll);\r\n\t        } else {\r\n\t            context.isAutoScrolling = false;\r\n\t            context.autoScrollTracker = null;\r\n\t        }\r\n\t    }\r\n\t\r\n\t    context.cancelAutoScroll = function () {\r\n\t        if ( context.isAutoScrolling ) {\r\n\t            cancelAnimationFrame(context.autoScrollTracker);\r\n\t            context.isAutoScrolling = false;\r\n\t            context.autoScrollTracker = null;\r\n\t        }\r\n\t    }\r\n\t\r\n\t    context.tap = function (e) {\r\n\t        context.pressed = true;\r\n\t        context.referenceX = utils.getPoint(e, context.hasTouch).x;\r\n\t        context.referenceY = utils.getPoint(e, context.hasTouch).y;\r\n\t\r\n\t        context.velocityTop = context.amplitudeTop = 0;\r\n\t        context.velocityLeft = context.amplitudeLeft = 0;\r\n\t\r\n\t        context.lastScrollTop = context.scrollTop;\r\n\t        context.lastScrollLeft = context.scrollLeft;\r\n\t\r\n\t        context.timeStamp = utils.getTime();\r\n\t\r\n\t        context.cancelAutoScroll();\r\n\t\r\n\t        context.$listener.addEventListener( 'mousemove', context.swipe, true );\r\n\t        context.$listener.addEventListener( 'mouseup', context.end, true );\r\n\t\r\n\t        e.preventDefault();\r\n\t        e.stopPropagation();\r\n\t        return false;\r\n\t    }\r\n\t\r\n\t    context.swipe = function (e) {\r\n\t        var x, y, deltaX, deltaY;\r\n\t\r\n\t        if (context.pressed) {\r\n\t            x = utils.getPoint(e, context.hasTouch).x;\r\n\t            y = utils.getPoint(e, context.hasTouch).y;\r\n\t\r\n\t            deltaX = context.referenceX - x;\r\n\t            deltaY = context.referenceY - y;\r\n\t\r\n\t            if (deltaX > 2 || deltaX < -2) {\r\n\t                context.referenceX = x;\r\n\t            } else {\r\n\t                deltaX = 0;\r\n\t            }\r\n\t            if (deltaY > 2 || deltaY < -2) {\r\n\t                context.referenceY = y;\r\n\t            } else {\r\n\t                deltaY = 0;\r\n\t            }\r\n\t\r\n\t            context.topTracker();\r\n\t            context.leftTracker();\r\n\t\r\n\t            context.scrollTo( context.scrollLeft + deltaX, context.scrollTop + deltaY );\r\n\t        }\r\n\t\r\n\t        e.preventDefault();\r\n\t        e.stopPropagation();\r\n\t        return false;\r\n\t    }\r\n\t\r\n\t    context.end = function(e) {\r\n\t        context.pressed = false;\r\n\t\r\n\t        context.timeStamp = utils.getTime();\r\n\t        context.topTracker();\r\n\t        context.leftTracker();\r\n\t\r\n\t        if (context.velocityTop > 10 || context.velocityTop < -10) {\r\n\t            context.amplitudeTop = 0.8 * context.velocityTop;\r\n\t            context.targetTop = Math.round(context.scrollTop + context.amplitudeTop);\r\n\t        } else {\r\n\t            context.targetTop = context.scrollTop;\r\n\t        }\r\n\t        if (context.velocityLeft > 10 || context.velocityLeft < -10) {\r\n\t            context.amplitudeLeft = 0.8 * context.velocityLeft;\r\n\t            context.targetLeft = Math.round(context.scrollLeft + context.amplitudeLeft);\r\n\t        } else {\r\n\t            context.targetLeft = context.scrollLeft;\r\n\t        }\r\n\t\r\n\t        context.isAutoScrolling = true;\r\n\t        context.autoScrollTracker = requestAnimationFrame(context.autoScroll);\r\n\t\r\n\t        context.$listener.removeEventListener( 'mousemove', context.swipe );\r\n\t        context.$listener.removeEventListener( 'mouseup', context.end );\r\n\t\r\n\t        e.preventDefault();\r\n\t        e.stopPropagation();\r\n\t        return false;\r\n\t    }\r\n\t\r\n\t    if ( ! context.hasTouch && context.userOptions.enableKinetics ) {\r\n\t        context.$listener.addEventListener( 'mousedown', context.tap, true );\r\n\t    }\r\n\t\r\n\t    context.$on('$destroy', function() {\r\n\t        context.$listener.removeEventListener( 'mousedown', context.tap );\r\n\t    });\r\n\t}\r\n\t\r\n\tmodule.exports = KineticEngine;\r\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\tfunction UtilsFactory () {\r\n\t    return {\r\n\t        findMatchingTarget: function (target, nodes) {\r\n\t            var found;\r\n\t\r\n\t            if ( ! nodes.length || target.tagName === 'BODY' ) {\r\n\t                return 'BODY';\r\n\t            }\r\n\t\r\n\t            found = nodes.find(function (node) {\r\n\t                return node.id === target.id\r\n\t            });\r\n\t\r\n\t            if ( found ) {\r\n\t                return target.id;\r\n\t            } else {\r\n\t                return this.findMatchingTarget(target.parentElement, nodes);\r\n\t            }\r\n\t        },\r\n\t        getPoint: function (e, hasTouch) {\r\n\t            var point;\r\n\t\r\n\t            if( hasTouch && event.touches.length ) {\r\n\t                point = {\r\n\t                    'x' : event.touches[0].clientX,\r\n\t                    'y' : event.touches[0].clientY\r\n\t                }\r\n\t            } else {\r\n\t                point = {\r\n\t                    'x' : event.clientX,\r\n\t                    'y' : event.clientY\r\n\t                }\r\n\t            }\r\n\t\r\n\t            return point;\r\n\t        },\r\n\t        getTime: Date.now || function getTime () {\r\n\t            return new Date().utils.getTime();\r\n\t        }\r\n\t    }\r\n\t}\r\n\t\r\n\tmodule.exports = UtilsFactory\r\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\t'use strict';\r\n\t\r\n\tfunction ConnectScrolls (utils, kineticEngine) {\r\n\t    return {\r\n\t        restrict: 'E',\r\n\t        scope: {\r\n\t            options: '='\r\n\t        },\r\n\t        transclude: true,\r\n\t        replace: true,\r\n\t        template: '<span data-name=\"conntect-scroll\" ng-transclude></span>',\r\n\t        link: function (scope, element) {\r\n\t            scope.hasTouch = 'ontouchstart' in window;\r\n\t            scope.DETECT_EVT = scope.hasTouch ? 'touchstart' : 'mouseover';\r\n\t            scope.activeId = undefined;\r\n\t            scope.$listener = element[0];\r\n\t\r\n\t            scope.defaultOptions = {\r\n\t                enableKinetics: false,\r\n\t                movingAverage: 0.1\r\n\t            };\r\n\t            scope.userOptions = angular.extend({}, scope.defaultOptions, scope.options);\r\n\t\r\n\t            kineticEngine.call(this, scope, utils);\r\n\t\r\n\t            scope.setActiveNode = function (e) {\r\n\t                scope.activeId = utils.findMatchingTarget(e.target, scope.childNodes);\r\n\t            }\r\n\t\r\n\t            scope.onScroll = function (e) {\r\n\t                if ( scope.pressed || scope.isAutoScrolling ) {\r\n\t                    e.preventDefault();\r\n\t                    e.stopPropagation();\r\n\t                    return;\r\n\t                }\r\n\t\r\n\t                var target = e.target;\r\n\t                var valX = undefined;\r\n\t                var valY = undefined;\r\n\t\r\n\t                if ( target.clientWidth !== target.scrollWidth ) {\r\n\t                    valX = target.scrollLeft;\r\n\t                    scope.lastScrollLeft = scope.scrollLeft;\r\n\t                    scope.scrollLeft = valX;\r\n\t                } else {\r\n\t                    valX = scope.scrollLeft;\r\n\t                }\r\n\t                if ( target.clientHeight !== target.scrollHeight ) {\r\n\t                    valY = target.scrollTop;\r\n\t                    scope.lastScrollTop = scope.scrollTop;\r\n\t                    scope.scrollTop = valY;\r\n\t                } else {\r\n\t                    valY = scope.scrollTop;\r\n\t                }\r\n\t\r\n\t                scope.childNodes.forEach(function(node) {\r\n\t                    if ( node.id !== scope.activeId ) {\r\n\t                        node.children[0].scrollLeft = valX;\r\n\t                        node.children[0].scrollTop = valY;\r\n\t                    }\r\n\t                });\r\n\t            }\r\n\t\r\n\t            scope.$listener.addEventListener( scope.DETECT_EVT, scope.setActiveNode, true );\r\n\t            scope.$listener.addEventListener( 'scroll', scope.onScroll, true );\r\n\t\r\n\t            scope.$on('$destroy', function() {\r\n\t                scope.$listener.removeEventListener( scope.DETECT_EVT, scope.setActiveNode );\r\n\t                scope.$listener.removeEventListener( 'scroll', scope.onScroll );\r\n\t            });\r\n\t\r\n\t            // expose few methods to the parent controller\r\n\t            scope.$parent.connectedScrolls = {\r\n\t                scrollToStart: function () {\r\n\t                    scope.cancelAutoScroll();\r\n\t                    scope.scrollTo(0, 0);\r\n\t                },\r\n\t                scrollToStartLeft: function () {\r\n\t                    scope.cancelAutoScroll();\r\n\t                    scope.scrollTo(0, scope.scrollTop);\r\n\t                },\r\n\t                scrollToStartTop: function () {\r\n\t                    scope.cancelAutoScroll();\r\n\t                    scope.scrollTo(scope.scrollLeft, 0);\r\n\t                },\r\n\t                scrollToEnd: function () {\r\n\t                    var maxScrollLeft = 0;\r\n\t                    var maxScrollTop = 0;\r\n\t\r\n\t                    scope.childNodes.forEach(function (node) {\r\n\t                        var $el = node.children[0];\r\n\t                        var maxScrollX = $el.scrollWidth - $el.clientWidth;\r\n\t                        var maxScrollY = $el.scrollHeight - $el.clientHeight;\r\n\t\r\n\t                        if ( maxScrollX > maxScrollLeft ) {\r\n\t                            maxScrollLeft = maxScrollX;\r\n\t                        }\r\n\t                        if ( maxScrollY > maxScrollTop ) {\r\n\t                            maxScrollTop = maxScrollY;\r\n\t                        }\r\n\t                    });\r\n\t\r\n\t                    scope.cancelAutoScroll();\r\n\t                    scope.scrollTo(maxScrollLeft, maxScrollTop);\r\n\t                },\r\n\t                scrollToEndLeft: function () {\r\n\t                    var maxScrollLeft = 0;\r\n\t\r\n\t                    scope.childNodes.forEach(function (node) {\r\n\t                        var $el = node.children[0];\r\n\t                        var maxScrollX = $el.scrollWidth - $el.clientWidth;\r\n\t\r\n\t                        if ( maxScrollX > maxScrollLeft ) {\r\n\t                            maxScrollLeft = maxScrollX;\r\n\t                        }\r\n\t                    });\r\n\t\r\n\t                    scope.cancelAutoScroll();\r\n\t                    scope.scrollTo(maxScrollLeft, scope.scrollTop);\r\n\t                },\r\n\t                scrollToEndTop: function () {\r\n\t                    var maxScrollTop = 0;\r\n\t\r\n\t                    scope.childNodes.forEach(function (node) {\r\n\t                        var $el = node.children[0];\r\n\t                        var maxScrollY = $el.scrollHeight - $el.clientHeight;\r\n\t\r\n\t                        if ( maxScrollY > maxScrollTop ) {\r\n\t                            maxScrollTop = maxScrollY;\r\n\t                        }\r\n\t                    });\r\n\t\r\n\t                    scope.cancelAutoScroll();\r\n\t                    scope.scrollTo(scope.scrollLeft, maxScrollTop);\r\n\t                }\r\n\t            }\r\n\t        },\r\n\t        controller: ['$scope', function connectScrollsCtrl($scope) {\r\n\t            var childNodes = $scope.childNodes = [];\r\n\t\r\n\t            this.addScrollArea = function (node) {\r\n\t                childNodes.push(node);\r\n\t            }\r\n\t        }]\r\n\t    }\r\n\t}\r\n\t\r\n\tConnectScrolls.$inject = ['utils', 'kineticEngine'];\r\n\t\r\n\tmodule.exports = ConnectScrolls;\r\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\t'use strict';\r\n\t\r\n\tfunction ScrollArea () {\r\n\t    return {\r\n\t        require: '^^connectScrolls',\r\n\t        restrict: 'E',\r\n\t        transclude: true,\r\n\t        replace: true,\r\n\t        template: '<span  data-name=\"scroll-area\" ng-transclude></span>',\r\n\t        link: function (scope, element, attrs, connectScrollsCtrl) {\r\n\t            element.attr( 'id', 'PARTICIPATING_NODE_' + Math.random().toString().substring(2, 15) );\r\n\t            connectScrollsCtrl.addScrollArea(element[0]);\r\n\t        }\r\n\t    }\r\n\t}\r\n\t\r\n\tmodule.exports = ScrollArea;\r\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\t'use strict';\r\n\t\r\n\tfunction KineticScroll (utils, kineticEngine) {\r\n\t    return {\r\n\t        restrict: 'E',\r\n\t        scope: {\r\n\t            options: '='\r\n\t        },\r\n\t        transclude: true,\r\n\t        replace: true,\r\n\t        template: '<span data-name=\"kinetic-scroll\" ng-transclude></span>',\r\n\t        link: function (scope, element) {\r\n\t            scope.hasTouch = 'ontouchstart' in window;\r\n\t            scope.DETECT_EVT = scope.hasTouch ? 'touchstart' : 'mouseover';\r\n\t            scope.$listener = element[0];\r\n\t            scope.childNodes = [ scope.$listener ];\r\n\t\r\n\t            scope.defaultOptions = {\r\n\t                enableKinetics: false,\r\n\t                movingAverage: 0.1\r\n\t            };\r\n\t            scope.userOptions = angular.extend({}, scope.defaultOptions, scope.options);\r\n\t\r\n\t            kineticEngine.call(this, scope, utils);\r\n\t\r\n\t            // expose few methods to the parent controller\r\n\t            scope.$parent.kineticScroll = {\r\n\t                scrollToStart: function () {\r\n\t                    scope.cancelAutoScroll();\r\n\t                    scope.scrollTo(0, 0);\r\n\t                },\r\n\t                scrollToStartLeft: function () {\r\n\t                    scope.cancelAutoScroll();\r\n\t                    scope.scrollTo(0, scope.scrollTop);\r\n\t                },\r\n\t                scrollToStartTop: function () {\r\n\t                    scope.cancelAutoScroll();\r\n\t                    scope.scrollTo(scope.scrollLeft, 0);\r\n\t                },\r\n\t                scrollToEnd: function () {\r\n\t                    var maxScrollLeft = 0;\r\n\t                    var maxScrollTop = 0;\r\n\t\r\n\t                    scope.childNodes.forEach(function (node) {\r\n\t                        var $el = node.children[0];\r\n\t                        var maxScrollX = $el.scrollWidth - $el.clientWidth;\r\n\t                        var maxScrollY = $el.scrollHeight - $el.clientHeight;\r\n\t\r\n\t                        if ( maxScrollX > maxScrollLeft ) {\r\n\t                            maxScrollLeft = maxScrollX;\r\n\t                        }\r\n\t                        if ( maxScrollY > maxScrollTop ) {\r\n\t                            maxScrollTop = maxScrollY;\r\n\t                        }\r\n\t                    });\r\n\t\r\n\t                    scope.cancelAutoScroll();\r\n\t                    scope.scrollTo(maxScrollLeft, maxScrollTop);\r\n\t                },\r\n\t                scrollToEndLeft: function () {\r\n\t                    var maxScrollLeft = 0;\r\n\t\r\n\t                    scope.childNodes.forEach(function (node) {\r\n\t                        var $el = node.children[0];\r\n\t                        var maxScrollX = $el.scrollWidth - $el.clientWidth;\r\n\t\r\n\t                        if ( maxScrollX > maxScrollLeft ) {\r\n\t                            maxScrollLeft = maxScrollX;\r\n\t                        }\r\n\t                    });\r\n\t\r\n\t                    scope.cancelAutoScroll();\r\n\t                    scope.scrollTo(maxScrollLeft, scope.scrollTop);\r\n\t                },\r\n\t                scrollToEndTop: function () {\r\n\t                    var maxScrollTop = 0;\r\n\t\r\n\t                    scope.childNodes.forEach(function (node) {\r\n\t                        var $el = node.children[0];\r\n\t                        var maxScrollY = $el.scrollHeight - $el.clientHeight;\r\n\t\r\n\t                        if ( maxScrollY > maxScrollTop ) {\r\n\t                            maxScrollTop = maxScrollY;\r\n\t                        }\r\n\t                    });\r\n\t\r\n\t                    scope.cancelAutoScroll();\r\n\t                    scope.scrollTo(scope.scrollLeft, maxScrollTop);\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t    }\r\n\t}\r\n\t\r\n\tKineticScroll.$inject = ['utils', 'kineticEngine'];\r\n\t\r\n\tmodule.exports = KineticScroll;\r\n\n\n/***/ }\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// ngAugmentNativeScroll.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap e7fe1802638f78092050","'use strict';\r\n\r\nangular.module('ngAugmentNativeScroll', [])\r\n    .value('kineticEngine', require('./kineticEngine.value'))\r\n    .factory('utils', require('./utils.factory'))\r\n    .directive('connectScrolls', require('./connectScrolls.directive'))\r\n    .directive('scrollArea', require('./scrollArea.directive'))\r\n    .directive('kineticScroll', require('./kineticScroll.directive'));\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./index.js\n// module id = 0\n// module chunks = 0","'use strict';\r\n\r\nfunction KineticEngine (context, utils) {\r\n    context.scrollLeft = 0;\r\n    context.scrollTop = 0;\r\n    context.lastScrollLeft = 0;\r\n    context.lastScrollTop = 0;\r\n    context.targetTop = 0;\r\n    context.targetLeft = 0;\r\n\r\n    context.velocityTop = 0;\r\n    context.velocityLeft = 0;\r\n    context.amplitudeTop = 0;\r\n    context.amplitudeLeft = 0;\r\n\r\n    context.timeStamp = 0;\r\n    context.referenceX = 0;\r\n    context.referenceY = 0;\r\n    context.pressed = false;\r\n    context.autoScrollTracker = null;\r\n    context.isAutoScrolling = false;\r\n\r\n    context.leftTracker = function () {\r\n        var now, elapsed, delta;\r\n\r\n        now = utils.getTime();\r\n        elapsed = now - context.timeStamp;\r\n        context.timeStamp = now;\r\n        delta = context.scrollLeft - context.lastScrollLeft;\r\n        context.lastScrollLeft = context.scrollLeft;\r\n\r\n        context.velocityLeft = context.userOptions.movingAverage * (1000 * delta / (1 + elapsed)) + 0.2 * context.velocityLeft;\r\n    }\r\n\r\n    context.topTracker = function () {\r\n        var now, elapsed, delta;\r\n\r\n        now = utils.getTime();\r\n        elapsed = now - context.timeStamp;\r\n        context.timeStamp = now;\r\n        delta = context.scrollTop - context.lastScrollTop;\r\n        context.lastScrollTop = context.scrollTop;\r\n\r\n        context.velocityTop = context.userOptions.movingAverage * (1000 * delta / (1 + elapsed)) + 0.2 * context.velocityTop;\r\n    }\r\n\r\n    context.scrollTo = function(left, top) {\r\n        var correctedLeft = Math.round(left);\r\n        var correctedTop = Math.round(top);\r\n\r\n        context.childNodes.forEach(function(node) {\r\n            var $el = node.children[0];\r\n            var maxScrollX = $el.scrollWidth - $el.clientWidth;\r\n            var maxScrollY = $el.scrollHeight - $el.clientHeight;\r\n\r\n            if ( maxScrollX > 0 && correctedLeft >= 0 && correctedLeft <= maxScrollX ) {\r\n                $el.scrollLeft = correctedLeft;\r\n                context.scrollLeft = correctedLeft;\r\n            }\r\n            if ( maxScrollY > 0 && correctedTop >= 0 && correctedTop <= maxScrollY ) {\r\n                $el.scrollTop = correctedTop;\r\n                context.scrollTop = correctedTop;\r\n            }\r\n        })\r\n    }\r\n\r\n    context.autoScroll = function() {\r\n        var elapsed;\r\n        var deltaY = 0, deltaX = 0, scrollX = 0, scrollY = 0;\r\n        var timeConstant = 325;\r\n\r\n        elapsed = utils.getTime() - context.timeStamp;\r\n\r\n        if ( context.amplitudeTop ) {\r\n            deltaY = -context.amplitudeTop * Math.exp(-elapsed / timeConstant);\r\n        }\r\n        if ( context.amplitudeLeft ) {\r\n            deltaX = -context.amplitudeLeft * Math.exp(-elapsed / timeConstant);\r\n        }\r\n\r\n        if ( deltaX > 0.5 || deltaX < -0.5 ) {\r\n            scrollX = deltaX;\r\n        } else {\r\n            scrollX = 0;\r\n        }\r\n\r\n        if ( deltaY > 0.5 || deltaY < -0.5 ) {\r\n            scrollY = deltaY;\r\n        } else {\r\n            scrollY = 0;\r\n        }\r\n\r\n        context.scrollTo(context.targetLeft + scrollX, context.targetTop + scrollY);\r\n\r\n        if ( scrollX !== 0 || scrollY !== 0 ) {\r\n            context.autoScrollTracker = requestAnimationFrame(context.autoScroll);\r\n        } else {\r\n            context.isAutoScrolling = false;\r\n            context.autoScrollTracker = null;\r\n        }\r\n    }\r\n\r\n    context.cancelAutoScroll = function () {\r\n        if ( context.isAutoScrolling ) {\r\n            cancelAnimationFrame(context.autoScrollTracker);\r\n            context.isAutoScrolling = false;\r\n            context.autoScrollTracker = null;\r\n        }\r\n    }\r\n\r\n    context.tap = function (e) {\r\n        context.pressed = true;\r\n        context.referenceX = utils.getPoint(e, context.hasTouch).x;\r\n        context.referenceY = utils.getPoint(e, context.hasTouch).y;\r\n\r\n        context.velocityTop = context.amplitudeTop = 0;\r\n        context.velocityLeft = context.amplitudeLeft = 0;\r\n\r\n        context.lastScrollTop = context.scrollTop;\r\n        context.lastScrollLeft = context.scrollLeft;\r\n\r\n        context.timeStamp = utils.getTime();\r\n\r\n        context.cancelAutoScroll();\r\n\r\n        context.$listener.addEventListener( 'mousemove', context.swipe, true );\r\n        context.$listener.addEventListener( 'mouseup', context.end, true );\r\n\r\n        e.preventDefault();\r\n        e.stopPropagation();\r\n        return false;\r\n    }\r\n\r\n    context.swipe = function (e) {\r\n        var x, y, deltaX, deltaY;\r\n\r\n        if (context.pressed) {\r\n            x = utils.getPoint(e, context.hasTouch).x;\r\n            y = utils.getPoint(e, context.hasTouch).y;\r\n\r\n            deltaX = context.referenceX - x;\r\n            deltaY = context.referenceY - y;\r\n\r\n            if (deltaX > 2 || deltaX < -2) {\r\n                context.referenceX = x;\r\n            } else {\r\n                deltaX = 0;\r\n            }\r\n            if (deltaY > 2 || deltaY < -2) {\r\n                context.referenceY = y;\r\n            } else {\r\n                deltaY = 0;\r\n            }\r\n\r\n            context.topTracker();\r\n            context.leftTracker();\r\n\r\n            context.scrollTo( context.scrollLeft + deltaX, context.scrollTop + deltaY );\r\n        }\r\n\r\n        e.preventDefault();\r\n        e.stopPropagation();\r\n        return false;\r\n    }\r\n\r\n    context.end = function(e) {\r\n        context.pressed = false;\r\n\r\n        context.timeStamp = utils.getTime();\r\n        context.topTracker();\r\n        context.leftTracker();\r\n\r\n        if (context.velocityTop > 10 || context.velocityTop < -10) {\r\n            context.amplitudeTop = 0.8 * context.velocityTop;\r\n            context.targetTop = Math.round(context.scrollTop + context.amplitudeTop);\r\n        } else {\r\n            context.targetTop = context.scrollTop;\r\n        }\r\n        if (context.velocityLeft > 10 || context.velocityLeft < -10) {\r\n            context.amplitudeLeft = 0.8 * context.velocityLeft;\r\n            context.targetLeft = Math.round(context.scrollLeft + context.amplitudeLeft);\r\n        } else {\r\n            context.targetLeft = context.scrollLeft;\r\n        }\r\n\r\n        context.isAutoScrolling = true;\r\n        context.autoScrollTracker = requestAnimationFrame(context.autoScroll);\r\n\r\n        context.$listener.removeEventListener( 'mousemove', context.swipe );\r\n        context.$listener.removeEventListener( 'mouseup', context.end );\r\n\r\n        e.preventDefault();\r\n        e.stopPropagation();\r\n        return false;\r\n    }\r\n\r\n    if ( ! context.hasTouch && context.userOptions.enableKinetics ) {\r\n        context.$listener.addEventListener( 'mousedown', context.tap, true );\r\n    }\r\n\r\n    context.$on('$destroy', function() {\r\n        context.$listener.removeEventListener( 'mousedown', context.tap );\r\n    });\r\n}\r\n\r\nmodule.exports = KineticEngine;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./kineticEngine.value.js\n// module id = 1\n// module chunks = 0","function UtilsFactory () {\r\n    return {\r\n        findMatchingTarget: function (target, nodes) {\r\n            var found;\r\n\r\n            if ( ! nodes.length || target.tagName === 'BODY' ) {\r\n                return 'BODY';\r\n            }\r\n\r\n            found = nodes.find(function (node) {\r\n                return node.id === target.id\r\n            });\r\n\r\n            if ( found ) {\r\n                return target.id;\r\n            } else {\r\n                return this.findMatchingTarget(target.parentElement, nodes);\r\n            }\r\n        },\r\n        getPoint: function (e, hasTouch) {\r\n            var point;\r\n\r\n            if( hasTouch && event.touches.length ) {\r\n                point = {\r\n                    'x' : event.touches[0].clientX,\r\n                    'y' : event.touches[0].clientY\r\n                }\r\n            } else {\r\n                point = {\r\n                    'x' : event.clientX,\r\n                    'y' : event.clientY\r\n                }\r\n            }\r\n\r\n            return point;\r\n        },\r\n        getTime: Date.now || function getTime () {\r\n            return new Date().utils.getTime();\r\n        }\r\n    }\r\n}\r\n\r\nmodule.exports = UtilsFactory\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./utils.factory.js\n// module id = 2\n// module chunks = 0","'use strict';\r\n\r\nfunction ConnectScrolls (utils, kineticEngine) {\r\n    return {\r\n        restrict: 'E',\r\n        scope: {\r\n            options: '='\r\n        },\r\n        transclude: true,\r\n        replace: true,\r\n        template: '<span data-name=\"conntect-scroll\" ng-transclude></span>',\r\n        link: function (scope, element) {\r\n            scope.hasTouch = 'ontouchstart' in window;\r\n            scope.DETECT_EVT = scope.hasTouch ? 'touchstart' : 'mouseover';\r\n            scope.activeId = undefined;\r\n            scope.$listener = element[0];\r\n\r\n            scope.defaultOptions = {\r\n                enableKinetics: false,\r\n                movingAverage: 0.1\r\n            };\r\n            scope.userOptions = angular.extend({}, scope.defaultOptions, scope.options);\r\n\r\n            kineticEngine.call(this, scope, utils);\r\n\r\n            scope.setActiveNode = function (e) {\r\n                scope.activeId = utils.findMatchingTarget(e.target, scope.childNodes);\r\n            }\r\n\r\n            scope.onScroll = function (e) {\r\n                if ( scope.pressed || scope.isAutoScrolling ) {\r\n                    e.preventDefault();\r\n                    e.stopPropagation();\r\n                    return;\r\n                }\r\n\r\n                var target = e.target;\r\n                var valX = undefined;\r\n                var valY = undefined;\r\n\r\n                if ( target.clientWidth !== target.scrollWidth ) {\r\n                    valX = target.scrollLeft;\r\n                    scope.lastScrollLeft = scope.scrollLeft;\r\n                    scope.scrollLeft = valX;\r\n                } else {\r\n                    valX = scope.scrollLeft;\r\n                }\r\n                if ( target.clientHeight !== target.scrollHeight ) {\r\n                    valY = target.scrollTop;\r\n                    scope.lastScrollTop = scope.scrollTop;\r\n                    scope.scrollTop = valY;\r\n                } else {\r\n                    valY = scope.scrollTop;\r\n                }\r\n\r\n                scope.childNodes.forEach(function(node) {\r\n                    if ( node.id !== scope.activeId ) {\r\n                        node.children[0].scrollLeft = valX;\r\n                        node.children[0].scrollTop = valY;\r\n                    }\r\n                });\r\n            }\r\n\r\n            scope.$listener.addEventListener( scope.DETECT_EVT, scope.setActiveNode, true );\r\n            scope.$listener.addEventListener( 'scroll', scope.onScroll, true );\r\n\r\n            scope.$on('$destroy', function() {\r\n                scope.$listener.removeEventListener( scope.DETECT_EVT, scope.setActiveNode );\r\n                scope.$listener.removeEventListener( 'scroll', scope.onScroll );\r\n            });\r\n\r\n            // expose few methods to the parent controller\r\n            scope.$parent.connectedScrolls = {\r\n                scrollToStart: function () {\r\n                    scope.cancelAutoScroll();\r\n                    scope.scrollTo(0, 0);\r\n                },\r\n                scrollToStartLeft: function () {\r\n                    scope.cancelAutoScroll();\r\n                    scope.scrollTo(0, scope.scrollTop);\r\n                },\r\n                scrollToStartTop: function () {\r\n                    scope.cancelAutoScroll();\r\n                    scope.scrollTo(scope.scrollLeft, 0);\r\n                },\r\n                scrollToEnd: function () {\r\n                    var maxScrollLeft = 0;\r\n                    var maxScrollTop = 0;\r\n\r\n                    scope.childNodes.forEach(function (node) {\r\n                        var $el = node.children[0];\r\n                        var maxScrollX = $el.scrollWidth - $el.clientWidth;\r\n                        var maxScrollY = $el.scrollHeight - $el.clientHeight;\r\n\r\n                        if ( maxScrollX > maxScrollLeft ) {\r\n                            maxScrollLeft = maxScrollX;\r\n                        }\r\n                        if ( maxScrollY > maxScrollTop ) {\r\n                            maxScrollTop = maxScrollY;\r\n                        }\r\n                    });\r\n\r\n                    scope.cancelAutoScroll();\r\n                    scope.scrollTo(maxScrollLeft, maxScrollTop);\r\n                },\r\n                scrollToEndLeft: function () {\r\n                    var maxScrollLeft = 0;\r\n\r\n                    scope.childNodes.forEach(function (node) {\r\n                        var $el = node.children[0];\r\n                        var maxScrollX = $el.scrollWidth - $el.clientWidth;\r\n\r\n                        if ( maxScrollX > maxScrollLeft ) {\r\n                            maxScrollLeft = maxScrollX;\r\n                        }\r\n                    });\r\n\r\n                    scope.cancelAutoScroll();\r\n                    scope.scrollTo(maxScrollLeft, scope.scrollTop);\r\n                },\r\n                scrollToEndTop: function () {\r\n                    var maxScrollTop = 0;\r\n\r\n                    scope.childNodes.forEach(function (node) {\r\n                        var $el = node.children[0];\r\n                        var maxScrollY = $el.scrollHeight - $el.clientHeight;\r\n\r\n                        if ( maxScrollY > maxScrollTop ) {\r\n                            maxScrollTop = maxScrollY;\r\n                        }\r\n                    });\r\n\r\n                    scope.cancelAutoScroll();\r\n                    scope.scrollTo(scope.scrollLeft, maxScrollTop);\r\n                }\r\n            }\r\n        },\r\n        controller: ['$scope', function connectScrollsCtrl($scope) {\r\n            var childNodes = $scope.childNodes = [];\r\n\r\n            this.addScrollArea = function (node) {\r\n                childNodes.push(node);\r\n            }\r\n        }]\r\n    }\r\n}\r\n\r\nConnectScrolls.$inject = ['utils', 'kineticEngine'];\r\n\r\nmodule.exports = ConnectScrolls;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./connectScrolls.directive.js\n// module id = 3\n// module chunks = 0","'use strict';\r\n\r\nfunction ScrollArea () {\r\n    return {\r\n        require: '^^connectScrolls',\r\n        restrict: 'E',\r\n        transclude: true,\r\n        replace: true,\r\n        template: '<span  data-name=\"scroll-area\" ng-transclude></span>',\r\n        link: function (scope, element, attrs, connectScrollsCtrl) {\r\n            element.attr( 'id', 'PARTICIPATING_NODE_' + Math.random().toString().substring(2, 15) );\r\n            connectScrollsCtrl.addScrollArea(element[0]);\r\n        }\r\n    }\r\n}\r\n\r\nmodule.exports = ScrollArea;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./scrollArea.directive.js\n// module id = 4\n// module chunks = 0","'use strict';\r\n\r\nfunction KineticScroll (utils, kineticEngine) {\r\n    return {\r\n        restrict: 'E',\r\n        scope: {\r\n            options: '='\r\n        },\r\n        transclude: true,\r\n        replace: true,\r\n        template: '<span data-name=\"kinetic-scroll\" ng-transclude></span>',\r\n        link: function (scope, element) {\r\n            scope.hasTouch = 'ontouchstart' in window;\r\n            scope.DETECT_EVT = scope.hasTouch ? 'touchstart' : 'mouseover';\r\n            scope.$listener = element[0];\r\n            scope.childNodes = [ scope.$listener ];\r\n\r\n            scope.defaultOptions = {\r\n                enableKinetics: false,\r\n                movingAverage: 0.1\r\n            };\r\n            scope.userOptions = angular.extend({}, scope.defaultOptions, scope.options);\r\n\r\n            kineticEngine.call(this, scope, utils);\r\n\r\n            // expose few methods to the parent controller\r\n            scope.$parent.kineticScroll = {\r\n                scrollToStart: function () {\r\n                    scope.cancelAutoScroll();\r\n                    scope.scrollTo(0, 0);\r\n                },\r\n                scrollToStartLeft: function () {\r\n                    scope.cancelAutoScroll();\r\n                    scope.scrollTo(0, scope.scrollTop);\r\n                },\r\n                scrollToStartTop: function () {\r\n                    scope.cancelAutoScroll();\r\n                    scope.scrollTo(scope.scrollLeft, 0);\r\n                },\r\n                scrollToEnd: function () {\r\n                    var maxScrollLeft = 0;\r\n                    var maxScrollTop = 0;\r\n\r\n                    scope.childNodes.forEach(function (node) {\r\n                        var $el = node.children[0];\r\n                        var maxScrollX = $el.scrollWidth - $el.clientWidth;\r\n                        var maxScrollY = $el.scrollHeight - $el.clientHeight;\r\n\r\n                        if ( maxScrollX > maxScrollLeft ) {\r\n                            maxScrollLeft = maxScrollX;\r\n                        }\r\n                        if ( maxScrollY > maxScrollTop ) {\r\n                            maxScrollTop = maxScrollY;\r\n                        }\r\n                    });\r\n\r\n                    scope.cancelAutoScroll();\r\n                    scope.scrollTo(maxScrollLeft, maxScrollTop);\r\n                },\r\n                scrollToEndLeft: function () {\r\n                    var maxScrollLeft = 0;\r\n\r\n                    scope.childNodes.forEach(function (node) {\r\n                        var $el = node.children[0];\r\n                        var maxScrollX = $el.scrollWidth - $el.clientWidth;\r\n\r\n                        if ( maxScrollX > maxScrollLeft ) {\r\n                            maxScrollLeft = maxScrollX;\r\n                        }\r\n                    });\r\n\r\n                    scope.cancelAutoScroll();\r\n                    scope.scrollTo(maxScrollLeft, scope.scrollTop);\r\n                },\r\n                scrollToEndTop: function () {\r\n                    var maxScrollTop = 0;\r\n\r\n                    scope.childNodes.forEach(function (node) {\r\n                        var $el = node.children[0];\r\n                        var maxScrollY = $el.scrollHeight - $el.clientHeight;\r\n\r\n                        if ( maxScrollY > maxScrollTop ) {\r\n                            maxScrollTop = maxScrollY;\r\n                        }\r\n                    });\r\n\r\n                    scope.cancelAutoScroll();\r\n                    scope.scrollTo(scope.scrollLeft, maxScrollTop);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nKineticScroll.$inject = ['utils', 'kineticEngine'];\r\n\r\nmodule.exports = KineticScroll;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./kineticScroll.directive.js\n// module id = 5\n// module chunks = 0"],"sourceRoot":""}