{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///./dist/ngAugmentNativeScroll.min.js","webpack:///webpack/bootstrap f30a4c2dc963658a96f0","webpack:///./src/index.js","webpack:///./src/utils.factory.js","webpack:///./src/kineticEngine.value.js","webpack:///./src/connectScrolls.directive.js","webpack:///./src/scrollArea.directive.js","webpack:///./src/kineticScroll.directive.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","angular","value","directive","UtilsFactory","findMatchingTarget","target","nodes","found","length","tagName","find","node","parentElement","getPoint","e","hasTouch","point","event","touches","x","clientX","y","clientY","getTime","Date","now","utils","KineticEngine","context","scrollLeft","scrollTop","lastScrollLeft","lastScrollTop","targetTop","targetLeft","velocityTop","velocityLeft","amplitudeTop","amplitudeLeft","timeStamp","referenceX","referenceY","pressed","autoScrollTracker","isAutoScrolling","leftTracker","elapsed","delta","userOptions","movingAverage","topTracker","scrollTo","left","top","correctedLeft","Math","round","correctedTop","childNodes","forEach","$el","children","maxScrollX","scrollWidth","clientWidth","maxScrollY","scrollHeight","clientHeight","autoScroll","deltaY","deltaX","scrollX","scrollY","timeConstant","exp","requestAnimationFrame","cancelAutoScroll","cancelAnimationFrame","tap","$listener","addEventListener","swipe","release","preventDefault","stopPropagation","removeEventListener","enableKinetics","$on","ConnectScrolls","kineticEngine","restrict","scope","options","transclude","replace","template","link","element","window","DETECT_EVT","activeId","undefined","defaultOptions","extend","setActiveNode","onScroll","valX","valY","$parent","connectedScrolls","scrollToStart","scrollToStartLeft","scrollToStartTop","scrollToEnd","maxScrollLeft","maxScrollTop","scrollToEndLeft","scrollToEndTop","controller","$scope","addScrollArea","push","$inject","ScrollArea","require","attrs","connectScrollsCtrl","attr","random","toString","substring","KineticScroll","kineticScroll"],"mappings":"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","file":"D:\\Work\\ng-augment-native-scroll/dist/ngAugmentNativeScroll.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ngAugmentNativeScroll\"] = factory();\n\telse\n\t\troot[\"ngAugmentNativeScroll\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","/*!\n * MIT License\n * \n * Copyright (c) 2017 Vijay Dev\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n * \n */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ngAugmentNativeScroll\"] = factory();\n\telse\n\t\troot[\"ngAugmentNativeScroll\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tangular.module('ngAugmentNativeScroll', []).factory('utils', __webpack_require__(1)).value('kineticEngine', __webpack_require__(2)).directive('connectScrolls', __webpack_require__(3)).directive('scrollArea', __webpack_require__(4)).directive('kineticScroll', __webpack_require__(5));\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\tfunction UtilsFactory() {\n\t    return {\n\t        findMatchingTarget: function (target, nodes) {\n\t            var found;\n\t\n\t            if (!nodes.length || target.tagName === 'BODY') {\n\t                return 'BODY';\n\t            }\n\t\n\t            found = nodes.find(function (node) {\n\t                return node.id === target.id;\n\t            });\n\t\n\t            if (found) {\n\t                return target.id;\n\t            } else {\n\t                return this.findMatchingTarget(target.parentElement, nodes);\n\t            }\n\t        },\n\t        getPoint: function (e, hasTouch) {\n\t            var point;\n\t\n\t            if (hasTouch && event.touches.length) {\n\t                point = {\n\t                    'x': event.touches[0].clientX,\n\t                    'y': event.touches[0].clientY\n\t                };\n\t            } else {\n\t                point = {\n\t                    'x': event.clientX,\n\t                    'y': event.clientY\n\t                };\n\t            }\n\t\n\t            return point;\n\t        },\n\t        getTime: Date.now || function getTime() {\n\t            return new Date().utils.getTime();\n\t        }\n\t    };\n\t}\n\t\n\tmodule.exports = UtilsFactory;\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tfunction KineticEngine(context, utils) {\n\t    context.scrollLeft = 0;\n\t    context.scrollTop = 0;\n\t    context.lastScrollLeft = 0;\n\t    context.lastScrollTop = 0;\n\t    context.targetTop = 0;\n\t    context.targetLeft = 0;\n\t\n\t    context.velocityTop = 0;\n\t    context.velocityLeft = 0;\n\t    context.amplitudeTop = 0;\n\t    context.amplitudeLeft = 0;\n\t\n\t    context.timeStamp = 0;\n\t    context.referenceX = 0;\n\t    context.referenceY = 0;\n\t    context.pressed = false;\n\t    context.autoScrollTracker = null;\n\t    context.isAutoScrolling = false;\n\t\n\t    context.leftTracker = function () {\n\t        var now, elapsed, delta;\n\t\n\t        now = utils.getTime();\n\t        elapsed = now - context.timeStamp;\n\t        context.timeStamp = now;\n\t        delta = context.scrollLeft - context.lastScrollLeft;\n\t        context.lastScrollLeft = context.scrollLeft;\n\t\n\t        context.velocityLeft = context.userOptions.movingAverage * (1000 * delta / (1 + elapsed)) + 0.2 * context.velocityLeft;\n\t    };\n\t\n\t    context.topTracker = function () {\n\t        var now, elapsed, delta;\n\t\n\t        now = utils.getTime();\n\t        elapsed = now - context.timeStamp;\n\t        context.timeStamp = now;\n\t        delta = context.scrollTop - context.lastScrollTop;\n\t        context.lastScrollTop = context.scrollTop;\n\t\n\t        context.velocityTop = context.userOptions.movingAverage * (1000 * delta / (1 + elapsed)) + 0.2 * context.velocityTop;\n\t    };\n\t\n\t    context.scrollTo = function (left, top) {\n\t        var correctedLeft = Math.round(left);\n\t        var correctedTop = Math.round(top);\n\t\n\t        context.childNodes.forEach(function (node) {\n\t            var $el = node.children[0];\n\t            var maxScrollX = $el.scrollWidth - $el.clientWidth;\n\t            var maxScrollY = $el.scrollHeight - $el.clientHeight;\n\t\n\t            if (maxScrollX > 0 && correctedLeft >= 0 && correctedLeft <= maxScrollX) {\n\t                $el.scrollLeft = correctedLeft;\n\t                context.scrollLeft = correctedLeft;\n\t            }\n\t            if (maxScrollY > 0 && correctedTop >= 0 && correctedTop <= maxScrollY) {\n\t                $el.scrollTop = correctedTop;\n\t                context.scrollTop = correctedTop;\n\t            }\n\t        });\n\t    };\n\t\n\t    context.autoScroll = function () {\n\t        var elapsed;\n\t        var deltaY = 0,\n\t            deltaX = 0,\n\t            scrollX = 0,\n\t            scrollY = 0;\n\t        var timeConstant = 325;\n\t\n\t        elapsed = utils.getTime() - context.timeStamp;\n\t\n\t        if (context.amplitudeTop) {\n\t            deltaY = -context.amplitudeTop * Math.exp(-elapsed / timeConstant);\n\t        }\n\t        if (context.amplitudeLeft) {\n\t            deltaX = -context.amplitudeLeft * Math.exp(-elapsed / timeConstant);\n\t        }\n\t\n\t        if (deltaX > 0.5 || deltaX < -0.5) {\n\t            scrollX = deltaX;\n\t        } else {\n\t            scrollX = 0;\n\t        }\n\t\n\t        if (deltaY > 0.5 || deltaY < -0.5) {\n\t            scrollY = deltaY;\n\t        } else {\n\t            scrollY = 0;\n\t        }\n\t\n\t        context.scrollTo(context.targetLeft + scrollX, context.targetTop + scrollY);\n\t\n\t        if (scrollX !== 0 || scrollY !== 0) {\n\t            context.autoScrollTracker = requestAnimationFrame(context.autoScroll);\n\t        } else {\n\t            context.isAutoScrolling = false;\n\t            context.autoScrollTracker = null;\n\t        }\n\t    };\n\t\n\t    context.cancelAutoScroll = function () {\n\t        if (context.isAutoScrolling) {\n\t            cancelAnimationFrame(context.autoScrollTracker);\n\t            context.isAutoScrolling = false;\n\t            context.autoScrollTracker = null;\n\t        }\n\t    };\n\t\n\t    context.tap = function (e) {\n\t        context.pressed = true;\n\t        context.referenceX = utils.getPoint(e, context.hasTouch).x;\n\t        context.referenceY = utils.getPoint(e, context.hasTouch).y;\n\t\n\t        context.velocityTop = context.amplitudeTop = 0;\n\t        context.velocityLeft = context.amplitudeLeft = 0;\n\t\n\t        context.lastScrollTop = context.scrollTop;\n\t        context.lastScrollLeft = context.scrollLeft;\n\t\n\t        context.timeStamp = utils.getTime();\n\t\n\t        context.cancelAutoScroll();\n\t\n\t        context.$listener.addEventListener('mousemove', context.swipe, true);\n\t        context.$listener.addEventListener('mouseup', context.release, true);\n\t\n\t        e.preventDefault();\n\t        e.stopPropagation();\n\t        return false;\n\t    };\n\t\n\t    context.swipe = function (e) {\n\t        var x, y, deltaX, deltaY;\n\t\n\t        if (context.pressed) {\n\t            x = utils.getPoint(e, context.hasTouch).x;\n\t            y = utils.getPoint(e, context.hasTouch).y;\n\t\n\t            deltaX = context.referenceX - x;\n\t            deltaY = context.referenceY - y;\n\t\n\t            if (deltaX > 2 || deltaX < -2) {\n\t                context.referenceX = x;\n\t            } else {\n\t                deltaX = 0;\n\t            }\n\t            if (deltaY > 2 || deltaY < -2) {\n\t                context.referenceY = y;\n\t            } else {\n\t                deltaY = 0;\n\t            }\n\t\n\t            context.topTracker();\n\t            context.leftTracker();\n\t\n\t            context.scrollTo(context.scrollLeft + deltaX, context.scrollTop + deltaY);\n\t        }\n\t\n\t        e.preventDefault();\n\t        e.stopPropagation();\n\t        return false;\n\t    };\n\t\n\t    context.release = function (e) {\n\t        context.pressed = false;\n\t\n\t        context.timeStamp = utils.getTime();\n\t        context.topTracker();\n\t        context.leftTracker();\n\t\n\t        if (context.velocityTop > 10 || context.velocityTop < -10) {\n\t            context.amplitudeTop = 0.8 * context.velocityTop;\n\t            context.targetTop = Math.round(context.scrollTop + context.amplitudeTop);\n\t        } else {\n\t            context.targetTop = context.scrollTop;\n\t        }\n\t        if (context.velocityLeft > 10 || context.velocityLeft < -10) {\n\t            context.amplitudeLeft = 0.8 * context.velocityLeft;\n\t            context.targetLeft = Math.round(context.scrollLeft + context.amplitudeLeft);\n\t        } else {\n\t            context.targetLeft = context.scrollLeft;\n\t        }\n\t\n\t        context.isAutoScrolling = true;\n\t        context.autoScrollTracker = requestAnimationFrame(context.autoScroll);\n\t\n\t        context.$listener.removeEventListener('mousemove', context.swipe);\n\t        context.$listener.removeEventListener('mouseup', context.release);\n\t\n\t        e.preventDefault();\n\t        e.stopPropagation();\n\t        return false;\n\t    };\n\t\n\t    if (!context.hasTouch && context.userOptions.enableKinetics) {\n\t        context.$listener.addEventListener('mousedown', context.tap, true);\n\t    }\n\t\n\t    context.$on('$destroy', function () {\n\t        context.$listener.removeEventListener('mousedown', context.tap);\n\t    });\n\t}\n\t\n\tmodule.exports = KineticEngine;\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tfunction ConnectScrolls(utils, kineticEngine) {\n\t    return {\n\t        restrict: 'E',\n\t        scope: {\n\t            options: '='\n\t        },\n\t        transclude: true,\n\t        replace: true,\n\t        template: '<span data-name=\"conntect-scroll\" ng-transclude></span>',\n\t        link: function (scope, element) {\n\t            scope.hasTouch = 'ontouchstart' in window;\n\t            scope.DETECT_EVT = scope.hasTouch ? 'touchstart' : 'mouseover';\n\t            scope.activeId = undefined;\n\t            scope.$listener = element[0];\n\t\n\t            scope.defaultOptions = {\n\t                enableKinetics: false,\n\t                movingAverage: 0.1\n\t            };\n\t            scope.userOptions = angular.extend({}, scope.defaultOptions, scope.options);\n\t\n\t            kineticEngine.call(this, scope, utils);\n\t\n\t            scope.setActiveNode = function (e) {\n\t                scope.activeId = utils.findMatchingTarget(e.target, scope.childNodes);\n\t            };\n\t\n\t            scope.onScroll = function (e) {\n\t                if (scope.pressed || scope.isAutoScrolling) {\n\t                    e.preventDefault();\n\t                    e.stopPropagation();\n\t                    return;\n\t                }\n\t\n\t                var target = e.target;\n\t                var valX = undefined;\n\t                var valY = undefined;\n\t\n\t                if (target.clientWidth !== target.scrollWidth) {\n\t                    valX = target.scrollLeft;\n\t                    scope.lastScrollLeft = scope.scrollLeft;\n\t                    scope.scrollLeft = valX;\n\t                } else {\n\t                    valX = scope.scrollLeft;\n\t                }\n\t                if (target.clientHeight !== target.scrollHeight) {\n\t                    valY = target.scrollTop;\n\t                    scope.lastScrollTop = scope.scrollTop;\n\t                    scope.scrollTop = valY;\n\t                } else {\n\t                    valY = scope.scrollTop;\n\t                }\n\t\n\t                scope.childNodes.forEach(function (node) {\n\t                    if (node.id !== scope.activeId) {\n\t                        node.children[0].scrollLeft = valX;\n\t                        node.children[0].scrollTop = valY;\n\t                    }\n\t                });\n\t            };\n\t\n\t            scope.$listener.addEventListener(scope.DETECT_EVT, scope.setActiveNode, true);\n\t            scope.$listener.addEventListener('scroll', scope.onScroll, true);\n\t\n\t            scope.$on('$destroy', function () {\n\t                scope.$listener.removeEventListener(scope.DETECT_EVT, scope.setActiveNode);\n\t                scope.$listener.removeEventListener('scroll', scope.onScroll);\n\t            });\n\t\n\t            // expose few methods to the parent controller\n\t            scope.$parent.connectedScrolls = {\n\t                scrollToStart: function () {\n\t                    scope.cancelAutoScroll();\n\t\n\t                    scope.timeStamp = utils.getTime();\n\t                    scope.targetLeft = 0;\n\t                    scope.targetTop = 0;\n\t                    scope.amplitudeLeft = -scope.scrollLeft;\n\t                    scope.amplitudeTop = -scope.scrollTop;\n\t\n\t                    scope.isAutoScrolling = true;\n\t                    scope.autoScrollTracker = requestAnimationFrame(scope.autoScroll);\n\t                },\n\t                scrollToStartLeft: function () {\n\t                    scope.cancelAutoScroll();\n\t\n\t                    scope.timeStamp = utils.getTime();\n\t                    scope.targetLeft = 0;\n\t                    scope.targetTop = scope.scrollTop;\n\t                    scope.amplitudeLeft = -scope.scrollLeft;\n\t                    scope.amplitudeTop = 0;\n\t\n\t                    scope.isAutoScrolling = true;\n\t                    scope.autoScrollTracker = requestAnimationFrame(scope.autoScroll);\n\t                },\n\t                scrollToStartTop: function () {\n\t                    scope.cancelAutoScroll();\n\t\n\t                    scope.timeStamp = utils.getTime();\n\t                    scope.targetLeft = scope.scrollLeft;\n\t                    scope.targetTop = 0;\n\t                    scope.amplitudeLeft = 0;\n\t                    scope.amplitudeTop = -scope.scrollTop;\n\t\n\t                    scope.isAutoScrolling = true;\n\t                    scope.autoScrollTracker = requestAnimationFrame(scope.autoScroll);\n\t                },\n\t                scrollToEnd: function () {\n\t                    var maxScrollLeft = 0;\n\t                    var maxScrollTop = 0;\n\t\n\t                    scope.childNodes.forEach(function (node) {\n\t                        var $el = node.children[0];\n\t                        var maxScrollX = $el.scrollWidth - $el.clientWidth;\n\t                        var maxScrollY = $el.scrollHeight - $el.clientHeight;\n\t\n\t                        if (maxScrollX > maxScrollLeft) {\n\t                            maxScrollLeft = maxScrollX;\n\t                        }\n\t                        if (maxScrollY > maxScrollTop) {\n\t                            maxScrollTop = maxScrollY;\n\t                        }\n\t                    });\n\t\n\t                    scope.cancelAutoScroll();\n\t                    scope.scrollTo(maxScrollLeft, maxScrollTop);\n\t                },\n\t                scrollToEndLeft: function () {\n\t                    var maxScrollLeft = 0;\n\t\n\t                    scope.childNodes.forEach(function (node) {\n\t                        var $el = node.children[0];\n\t                        var maxScrollX = $el.scrollWidth - $el.clientWidth;\n\t\n\t                        if (maxScrollX > maxScrollLeft) {\n\t                            maxScrollLeft = maxScrollX;\n\t                        }\n\t                    });\n\t\n\t                    scope.cancelAutoScroll();\n\t                    scope.scrollTo(maxScrollLeft, scope.scrollTop);\n\t                },\n\t                scrollToEndTop: function () {\n\t                    var maxScrollTop = 0;\n\t\n\t                    scope.childNodes.forEach(function (node) {\n\t                        var $el = node.children[0];\n\t                        var maxScrollY = $el.scrollHeight - $el.clientHeight;\n\t\n\t                        if (maxScrollY > maxScrollTop) {\n\t                            maxScrollTop = maxScrollY;\n\t                        }\n\t                    });\n\t\n\t                    scope.cancelAutoScroll();\n\t                    scope.scrollTo(scope.scrollLeft, maxScrollTop);\n\t                }\n\t            };\n\t        },\n\t        controller: ['$scope', function connectScrollsCtrl($scope) {\n\t            var childNodes = $scope.childNodes = [];\n\t\n\t            this.addScrollArea = function (node) {\n\t                childNodes.push(node);\n\t            };\n\t        }]\n\t    };\n\t}\n\t\n\tConnectScrolls.$inject = ['utils', 'kineticEngine'];\n\t\n\tmodule.exports = ConnectScrolls;\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tfunction ScrollArea() {\n\t    return {\n\t        require: '^^connectScrolls',\n\t        restrict: 'E',\n\t        transclude: true,\n\t        replace: true,\n\t        template: '<span  data-name=\"scroll-area\" ng-transclude></span>',\n\t        link: function (scope, element, attrs, connectScrollsCtrl) {\n\t            element.attr('id', 'PARTICIPATING_NODE_' + Math.random().toString().substring(2, 15));\n\t            connectScrollsCtrl.addScrollArea(element[0]);\n\t        }\n\t    };\n\t}\n\t\n\tmodule.exports = ScrollArea;\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tfunction KineticScroll(utils, kineticEngine) {\n\t    return {\n\t        restrict: 'E',\n\t        scope: {\n\t            options: '='\n\t        },\n\t        transclude: true,\n\t        replace: true,\n\t        template: '<span data-name=\"kinetic-scroll\" ng-transclude></span>',\n\t        link: function (scope, element) {\n\t            scope.hasTouch = 'ontouchstart' in window;\n\t            scope.DETECT_EVT = scope.hasTouch ? 'touchstart' : 'mouseover';\n\t            scope.$listener = element[0];\n\t            scope.childNodes = [scope.$listener];\n\t\n\t            scope.defaultOptions = {\n\t                enableKinetics: false,\n\t                movingAverage: 0.1\n\t            };\n\t            scope.userOptions = angular.extend({}, scope.defaultOptions, scope.options);\n\t\n\t            kineticEngine.call(this, scope, utils);\n\t\n\t            // expose few methods to the parent controller\n\t            scope.$parent.kineticScroll = {\n\t                scrollToStart: function () {\n\t                    scope.cancelAutoScroll();\n\t                    scope.scrollTo(0, 0);\n\t                },\n\t                scrollToStartLeft: function () {\n\t                    scope.cancelAutoScroll();\n\t                    scope.scrollTo(0, scope.scrollTop);\n\t                },\n\t                scrollToStartTop: function () {\n\t                    scope.cancelAutoScroll();\n\t                    scope.scrollTo(scope.scrollLeft, 0);\n\t                },\n\t                scrollToEnd: function () {\n\t                    var maxScrollLeft = 0;\n\t                    var maxScrollTop = 0;\n\t\n\t                    scope.childNodes.forEach(function (node) {\n\t                        var $el = node.children[0];\n\t                        var maxScrollX = $el.scrollWidth - $el.clientWidth;\n\t                        var maxScrollY = $el.scrollHeight - $el.clientHeight;\n\t\n\t                        if (maxScrollX > maxScrollLeft) {\n\t                            maxScrollLeft = maxScrollX;\n\t                        }\n\t                        if (maxScrollY > maxScrollTop) {\n\t                            maxScrollTop = maxScrollY;\n\t                        }\n\t                    });\n\t\n\t                    scope.cancelAutoScroll();\n\t                    scope.scrollTo(maxScrollLeft, maxScrollTop);\n\t                },\n\t                scrollToEndLeft: function () {\n\t                    var maxScrollLeft = 0;\n\t\n\t                    scope.childNodes.forEach(function (node) {\n\t                        var $el = node.children[0];\n\t                        var maxScrollX = $el.scrollWidth - $el.clientWidth;\n\t\n\t                        if (maxScrollX > maxScrollLeft) {\n\t                            maxScrollLeft = maxScrollX;\n\t                        }\n\t                    });\n\t\n\t                    scope.cancelAutoScroll();\n\t                    scope.scrollTo(maxScrollLeft, scope.scrollTop);\n\t                },\n\t                scrollToEndTop: function () {\n\t                    var maxScrollTop = 0;\n\t\n\t                    scope.childNodes.forEach(function (node) {\n\t                        var $el = node.children[0];\n\t                        var maxScrollY = $el.scrollHeight - $el.clientHeight;\n\t\n\t                        if (maxScrollY > maxScrollTop) {\n\t                            maxScrollTop = maxScrollY;\n\t                        }\n\t                    });\n\t\n\t                    scope.cancelAutoScroll();\n\t                    scope.scrollTo(scope.scrollLeft, maxScrollTop);\n\t                }\n\t            };\n\t        }\n\t    };\n\t}\n\t\n\tKineticScroll.$inject = ['utils', 'kineticEngine'];\n\t\n\tmodule.exports = KineticScroll;\n\n/***/ }\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// ./dist/ngAugmentNativeScroll.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap f30a4c2dc963658a96f0","'use strict';\n\nangular.module('ngAugmentNativeScroll', [])\n    .factory('utils', require('./utils.factory.js'))\n    .value('kineticEngine', require('./kineticEngine.value.js'))\n    .directive('connectScrolls', require('./connectScrolls.directive.js'))\n    .directive('scrollArea', require('./scrollArea.directive.js'))\n    .directive('kineticScroll', require('./kineticScroll.directive.js'));\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","function UtilsFactory () {\n    return {\n        findMatchingTarget: function (target, nodes) {\n            var found;\n\n            if ( ! nodes.length || target.tagName === 'BODY' ) {\n                return 'BODY';\n            }\n\n            found = nodes.find(function (node) {\n                return node.id === target.id\n            });\n\n            if ( found ) {\n                return target.id;\n            } else {\n                return this.findMatchingTarget(target.parentElement, nodes);\n            }\n        },\n        getPoint: function (e, hasTouch) {\n            var point;\n\n            if( hasTouch && event.touches.length ) {\n                point = {\n                    'x' : event.touches[0].clientX,\n                    'y' : event.touches[0].clientY\n                }\n            } else {\n                point = {\n                    'x' : event.clientX,\n                    'y' : event.clientY\n                }\n            }\n\n            return point;\n        },\n        getTime: Date.now || function getTime () {\n            return new Date().utils.getTime();\n        }\n    }\n}\n\nmodule.exports = UtilsFactory\n\n\n\n// WEBPACK FOOTER //\n// ./src/utils.factory.js","'use strict';\n\nfunction KineticEngine (context, utils) {\n    context.scrollLeft = 0;\n    context.scrollTop = 0;\n    context.lastScrollLeft = 0;\n    context.lastScrollTop = 0;\n    context.targetTop = 0;\n    context.targetLeft = 0;\n\n    context.velocityTop = 0;\n    context.velocityLeft = 0;\n    context.amplitudeTop = 0;\n    context.amplitudeLeft = 0;\n\n    context.timeStamp = 0;\n    context.referenceX = 0;\n    context.referenceY = 0;\n    context.pressed = false;\n    context.autoScrollTracker = null;\n    context.isAutoScrolling = false;\n\n    context.leftTracker = function () {\n        var now, elapsed, delta;\n\n        now = utils.getTime();\n        elapsed = now - context.timeStamp;\n        context.timeStamp = now;\n        delta = context.scrollLeft - context.lastScrollLeft;\n        context.lastScrollLeft = context.scrollLeft;\n\n        context.velocityLeft = context.userOptions.movingAverage * (1000 * delta / (1 + elapsed)) + 0.2 * context.velocityLeft;\n    }\n\n    context.topTracker = function () {\n        var now, elapsed, delta;\n\n        now = utils.getTime();\n        elapsed = now - context.timeStamp;\n        context.timeStamp = now;\n        delta = context.scrollTop - context.lastScrollTop;\n        context.lastScrollTop = context.scrollTop;\n\n        context.velocityTop = context.userOptions.movingAverage * (1000 * delta / (1 + elapsed)) + 0.2 * context.velocityTop;\n    }\n\n    context.scrollTo = function(left, top) {\n        var correctedLeft = Math.round(left);\n        var correctedTop = Math.round(top);\n\n        context.childNodes.forEach(function(node) {\n            var $el = node.children[0];\n            var maxScrollX = $el.scrollWidth - $el.clientWidth;\n            var maxScrollY = $el.scrollHeight - $el.clientHeight;\n\n            if ( maxScrollX > 0 && correctedLeft >= 0 && correctedLeft <= maxScrollX ) {\n                $el.scrollLeft = correctedLeft;\n                context.scrollLeft = correctedLeft;\n            }\n            if ( maxScrollY > 0 && correctedTop >= 0 && correctedTop <= maxScrollY ) {\n                $el.scrollTop = correctedTop;\n                context.scrollTop = correctedTop;\n            }\n        })\n    }\n\n    context.autoScroll = function() {\n        var elapsed;\n        var deltaY = 0, deltaX = 0, scrollX = 0, scrollY = 0;\n        var timeConstant = 325;\n\n        elapsed = utils.getTime() - context.timeStamp;\n\n        if ( context.amplitudeTop ) {\n            deltaY = -context.amplitudeTop * Math.exp(-elapsed / timeConstant);\n        }\n        if ( context.amplitudeLeft ) {\n            deltaX = -context.amplitudeLeft * Math.exp(-elapsed / timeConstant);\n        }\n\n        if ( deltaX > 0.5 || deltaX < -0.5 ) {\n            scrollX = deltaX;\n        } else {\n            scrollX = 0;\n        }\n\n        if ( deltaY > 0.5 || deltaY < -0.5 ) {\n            scrollY = deltaY;\n        } else {\n            scrollY = 0;\n        }\n\n        context.scrollTo(context.targetLeft + scrollX, context.targetTop + scrollY);\n\n        if ( scrollX !== 0 || scrollY !== 0 ) {\n            context.autoScrollTracker = requestAnimationFrame(context.autoScroll);\n        } else {\n            context.isAutoScrolling = false;\n            context.autoScrollTracker = null;\n        }\n    }\n\n    context.cancelAutoScroll = function () {\n        if ( context.isAutoScrolling ) {\n            cancelAnimationFrame(context.autoScrollTracker);\n            context.isAutoScrolling = false;\n            context.autoScrollTracker = null;\n        }\n    }\n\n    context.tap = function (e) {\n        context.pressed = true;\n        context.referenceX = utils.getPoint(e, context.hasTouch).x;\n        context.referenceY = utils.getPoint(e, context.hasTouch).y;\n\n        context.velocityTop = context.amplitudeTop = 0;\n        context.velocityLeft = context.amplitudeLeft = 0;\n\n        context.lastScrollTop = context.scrollTop;\n        context.lastScrollLeft = context.scrollLeft;\n\n        context.timeStamp = utils.getTime();\n\n        context.cancelAutoScroll();\n\n        context.$listener.addEventListener( 'mousemove', context.swipe, true );\n        context.$listener.addEventListener( 'mouseup', context.release, true );\n\n        e.preventDefault();\n        e.stopPropagation();\n        return false;\n    }\n\n    context.swipe = function (e) {\n        var x, y, deltaX, deltaY;\n\n        if (context.pressed) {\n            x = utils.getPoint(e, context.hasTouch).x;\n            y = utils.getPoint(e, context.hasTouch).y;\n\n            deltaX = context.referenceX - x;\n            deltaY = context.referenceY - y;\n\n            if (deltaX > 2 || deltaX < -2) {\n                context.referenceX = x;\n            } else {\n                deltaX = 0;\n            }\n            if (deltaY > 2 || deltaY < -2) {\n                context.referenceY = y;\n            } else {\n                deltaY = 0;\n            }\n\n            context.topTracker();\n            context.leftTracker();\n\n            context.scrollTo( context.scrollLeft + deltaX, context.scrollTop + deltaY );\n        }\n\n        e.preventDefault();\n        e.stopPropagation();\n        return false;\n    }\n\n    context.release = function(e) {\n        context.pressed = false;\n\n        context.timeStamp = utils.getTime();\n        context.topTracker();\n        context.leftTracker();\n\n        if (context.velocityTop > 10 || context.velocityTop < -10) {\n            context.amplitudeTop = 0.8 * context.velocityTop;\n            context.targetTop = Math.round(context.scrollTop + context.amplitudeTop);\n        } else {\n            context.targetTop = context.scrollTop;\n        }\n        if (context.velocityLeft > 10 || context.velocityLeft < -10) {\n            context.amplitudeLeft = 0.8 * context.velocityLeft;\n            context.targetLeft = Math.round(context.scrollLeft + context.amplitudeLeft);\n        } else {\n            context.targetLeft = context.scrollLeft;\n        }\n\n        context.isAutoScrolling = true;\n        context.autoScrollTracker = requestAnimationFrame(context.autoScroll);\n\n        context.$listener.removeEventListener( 'mousemove', context.swipe );\n        context.$listener.removeEventListener( 'mouseup', context.release );\n\n        e.preventDefault();\n        e.stopPropagation();\n        return false;\n    }\n\n    if ( ! context.hasTouch && context.userOptions.enableKinetics ) {\n        context.$listener.addEventListener( 'mousedown', context.tap, true );\n    }\n\n    context.$on('$destroy', function() {\n        context.$listener.removeEventListener( 'mousedown', context.tap );\n    });\n}\n\nmodule.exports = KineticEngine;\n\n\n\n// WEBPACK FOOTER //\n// ./src/kineticEngine.value.js","'use strict';\n\nfunction ConnectScrolls (utils, kineticEngine) {\n    return {\n        restrict: 'E',\n        scope: {\n            options: '='\n        },\n        transclude: true,\n        replace: true,\n        template: '<span data-name=\"conntect-scroll\" ng-transclude></span>',\n        link: function (scope, element) {\n            scope.hasTouch = 'ontouchstart' in window;\n            scope.DETECT_EVT = scope.hasTouch ? 'touchstart' : 'mouseover';\n            scope.activeId = undefined;\n            scope.$listener = element[0];\n\n            scope.defaultOptions = {\n                enableKinetics: false,\n                movingAverage: 0.1\n            };\n            scope.userOptions = angular.extend({}, scope.defaultOptions, scope.options);\n\n            kineticEngine.call(this, scope, utils);\n\n            scope.setActiveNode = function (e) {\n                scope.activeId = utils.findMatchingTarget(e.target, scope.childNodes);\n            }\n\n            scope.onScroll = function (e) {\n                if ( scope.pressed || scope.isAutoScrolling ) {\n                    e.preventDefault();\n                    e.stopPropagation();\n                    return;\n                }\n\n                var target = e.target;\n                var valX = undefined;\n                var valY = undefined;\n\n                if ( target.clientWidth !== target.scrollWidth ) {\n                    valX = target.scrollLeft;\n                    scope.lastScrollLeft = scope.scrollLeft;\n                    scope.scrollLeft = valX;\n                } else {\n                    valX = scope.scrollLeft;\n                }\n                if ( target.clientHeight !== target.scrollHeight ) {\n                    valY = target.scrollTop;\n                    scope.lastScrollTop = scope.scrollTop;\n                    scope.scrollTop = valY;\n                } else {\n                    valY = scope.scrollTop;\n                }\n\n                scope.childNodes.forEach(function(node) {\n                    if ( node.id !== scope.activeId ) {\n                        node.children[0].scrollLeft = valX;\n                        node.children[0].scrollTop = valY;\n                    }\n                });\n            }\n\n            scope.$listener.addEventListener( scope.DETECT_EVT, scope.setActiveNode, true );\n            scope.$listener.addEventListener( 'scroll', scope.onScroll, true );\n\n            scope.$on('$destroy', function() {\n                scope.$listener.removeEventListener( scope.DETECT_EVT, scope.setActiveNode );\n                scope.$listener.removeEventListener( 'scroll', scope.onScroll );\n            });\n\n            // expose few methods to the parent controller\n            scope.$parent.connectedScrolls = {\n                scrollToStart: function () {\n                    scope.cancelAutoScroll();\n\n                    scope.timeStamp = utils.getTime();\n                    scope.targetLeft = 0;\n                    scope.targetTop = 0;\n                    scope.amplitudeLeft = -scope.scrollLeft\n                    scope.amplitudeTop = -scope.scrollTop;\n\n                    scope.isAutoScrolling = true;\n                    scope.autoScrollTracker = requestAnimationFrame(scope.autoScroll);\n                },\n                scrollToStartLeft: function () {\n                    scope.cancelAutoScroll();\n\n                    scope.timeStamp = utils.getTime();\n                    scope.targetLeft = 0;\n                    scope.targetTop = scope.scrollTop;\n                    scope.amplitudeLeft = -scope.scrollLeft;\n                    scope.amplitudeTop = 0;\n\n                    scope.isAutoScrolling = true;\n                    scope.autoScrollTracker = requestAnimationFrame(scope.autoScroll);\n                },\n                scrollToStartTop: function () {\n                    scope.cancelAutoScroll();\n\n                    scope.timeStamp = utils.getTime();\n                    scope.targetLeft = scope.scrollLeft;\n                    scope.targetTop = 0;\n                    scope.amplitudeLeft = 0;\n                    scope.amplitudeTop = -scope.scrollTop;\n\n                    scope.isAutoScrolling = true;\n                    scope.autoScrollTracker = requestAnimationFrame(scope.autoScroll);\n                },\n                scrollToEnd: function () {\n                    var maxScrollLeft = 0;\n                    var maxScrollTop = 0;\n\n                    scope.childNodes.forEach(function (node) {\n                        var $el = node.children[0];\n                        var maxScrollX = $el.scrollWidth - $el.clientWidth;\n                        var maxScrollY = $el.scrollHeight - $el.clientHeight;\n\n                        if ( maxScrollX > maxScrollLeft ) {\n                            maxScrollLeft = maxScrollX;\n                        }\n                        if ( maxScrollY > maxScrollTop ) {\n                            maxScrollTop = maxScrollY;\n                        }\n                    });\n\n                    scope.cancelAutoScroll();\n                    scope.scrollTo(maxScrollLeft, maxScrollTop);\n                },\n                scrollToEndLeft: function () {\n                    var maxScrollLeft = 0;\n\n                    scope.childNodes.forEach(function (node) {\n                        var $el = node.children[0];\n                        var maxScrollX = $el.scrollWidth - $el.clientWidth;\n\n                        if ( maxScrollX > maxScrollLeft ) {\n                            maxScrollLeft = maxScrollX;\n                        }\n                    });\n\n                    scope.cancelAutoScroll();\n                    scope.scrollTo(maxScrollLeft, scope.scrollTop);\n                },\n                scrollToEndTop: function () {\n                    var maxScrollTop = 0;\n\n                    scope.childNodes.forEach(function (node) {\n                        var $el = node.children[0];\n                        var maxScrollY = $el.scrollHeight - $el.clientHeight;\n\n                        if ( maxScrollY > maxScrollTop ) {\n                            maxScrollTop = maxScrollY;\n                        }\n                    });\n\n                    scope.cancelAutoScroll();\n                    scope.scrollTo(scope.scrollLeft, maxScrollTop);\n                }\n            }\n        },\n        controller: ['$scope', function connectScrollsCtrl($scope) {\n            var childNodes = $scope.childNodes = [];\n\n            this.addScrollArea = function (node) {\n                childNodes.push(node);\n            }\n        }]\n    }\n}\n\nConnectScrolls.$inject = ['utils', 'kineticEngine'];\n\nmodule.exports = ConnectScrolls;\n\n\n\n// WEBPACK FOOTER //\n// ./src/connectScrolls.directive.js","'use strict';\n\nfunction ScrollArea () {\n    return {\n        require: '^^connectScrolls',\n        restrict: 'E',\n        transclude: true,\n        replace: true,\n        template: '<span  data-name=\"scroll-area\" ng-transclude></span>',\n        link: function (scope, element, attrs, connectScrollsCtrl) {\n            element.attr( 'id', 'PARTICIPATING_NODE_' + Math.random().toString().substring(2, 15) );\n            connectScrollsCtrl.addScrollArea(element[0]);\n        }\n    }\n}\n\nmodule.exports = ScrollArea;\n\n\n\n// WEBPACK FOOTER //\n// ./src/scrollArea.directive.js","'use strict';\n\nfunction KineticScroll (utils, kineticEngine) {\n    return {\n        restrict: 'E',\n        scope: {\n            options: '='\n        },\n        transclude: true,\n        replace: true,\n        template: '<span data-name=\"kinetic-scroll\" ng-transclude></span>',\n        link: function (scope, element) {\n            scope.hasTouch = 'ontouchstart' in window;\n            scope.DETECT_EVT = scope.hasTouch ? 'touchstart' : 'mouseover';\n            scope.$listener = element[0];\n            scope.childNodes = [ scope.$listener ];\n\n            scope.defaultOptions = {\n                enableKinetics: false,\n                movingAverage: 0.1\n            };\n            scope.userOptions = angular.extend({}, scope.defaultOptions, scope.options);\n\n            kineticEngine.call(this, scope, utils);\n\n            // expose few methods to the parent controller\n            scope.$parent.kineticScroll = {\n                scrollToStart: function () {\n                    scope.cancelAutoScroll();\n                    scope.scrollTo(0, 0);\n                },\n                scrollToStartLeft: function () {\n                    scope.cancelAutoScroll();\n                    scope.scrollTo(0, scope.scrollTop);\n                },\n                scrollToStartTop: function () {\n                    scope.cancelAutoScroll();\n                    scope.scrollTo(scope.scrollLeft, 0);\n                },\n                scrollToEnd: function () {\n                    var maxScrollLeft = 0;\n                    var maxScrollTop = 0;\n\n                    scope.childNodes.forEach(function (node) {\n                        var $el = node.children[0];\n                        var maxScrollX = $el.scrollWidth - $el.clientWidth;\n                        var maxScrollY = $el.scrollHeight - $el.clientHeight;\n\n                        if ( maxScrollX > maxScrollLeft ) {\n                            maxScrollLeft = maxScrollX;\n                        }\n                        if ( maxScrollY > maxScrollTop ) {\n                            maxScrollTop = maxScrollY;\n                        }\n                    });\n\n                    scope.cancelAutoScroll();\n                    scope.scrollTo(maxScrollLeft, maxScrollTop);\n                },\n                scrollToEndLeft: function () {\n                    var maxScrollLeft = 0;\n\n                    scope.childNodes.forEach(function (node) {\n                        var $el = node.children[0];\n                        var maxScrollX = $el.scrollWidth - $el.clientWidth;\n\n                        if ( maxScrollX > maxScrollLeft ) {\n                            maxScrollLeft = maxScrollX;\n                        }\n                    });\n\n                    scope.cancelAutoScroll();\n                    scope.scrollTo(maxScrollLeft, scope.scrollTop);\n                },\n                scrollToEndTop: function () {\n                    var maxScrollTop = 0;\n\n                    scope.childNodes.forEach(function (node) {\n                        var $el = node.children[0];\n                        var maxScrollY = $el.scrollHeight - $el.clientHeight;\n\n                        if ( maxScrollY > maxScrollTop ) {\n                            maxScrollTop = maxScrollY;\n                        }\n                    });\n\n                    scope.cancelAutoScroll();\n                    scope.scrollTo(scope.scrollLeft, maxScrollTop);\n                }\n            }\n        }\n    }\n}\n\nKineticScroll.$inject = ['utils', 'kineticEngine'];\n\nmodule.exports = KineticScroll;\n\n\n\n// WEBPACK FOOTER //\n// ./src/kineticScroll.directive.js"],"sourceRoot":""}